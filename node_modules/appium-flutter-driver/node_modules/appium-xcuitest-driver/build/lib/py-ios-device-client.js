"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Pyidevice = void 0;

require("source-map-support/register");

var _teen_process = require("teen_process");

var _support = require("@appium/support");

var _logger = _interopRequireDefault(require("./logger"));

var _path = _interopRequireDefault(require("path"));

const BINARY_NAME = 'pyidevice';

class Pyidevice {
  constructor(udid) {
    this.udid = udid;
    this.binaryPath = null;
  }

  async assertExists(isStrict = true) {
    if (this.binaryPath) {
      return true;
    }

    try {
      this.binaryPath = await _support.fs.which(BINARY_NAME);
      return true;
    } catch (e) {
      if (isStrict) {
        throw new Error(`${BINARY_NAME} binary cannot be found in PATH. ` + `Please make sure it is installed. Visit https://github.com/YueChen-C/py-ios-device for ` + `more details.`);
      }

      return false;
    }
  }

  async execute(args, opts = {}) {
    await this.assertExists();
    const {
      cwd,
      format = 'json',
      logStdout = false,
      asynchronous = false
    } = opts;
    const finalArgs = [...args, '--udid', this.udid];

    if (format) {
      finalArgs.push('--format', format);
    }

    const cmdStr = _support.util.quote([this.binaryPath, ...finalArgs]);

    _logger.default.debug(`Executing ${cmdStr}`);

    try {
      if (asynchronous) {
        const result = new _teen_process.SubProcess(this.binaryPath, finalArgs, {
          cwd
        });
        await result.start(0);
        return result;
      }

      const result = await (0, _teen_process.exec)(this.binaryPath, finalArgs, {
        cwd
      });

      if (logStdout) {
        _logger.default.debug(`Command output: ${result.stdout}`);
      }

      return result;
    } catch (e) {
      throw new Error(`'${cmdStr}' failed. Original error: ${e.stderr || e.stdout || e.message}`);
    }
  }

  async listProfiles() {
    const {
      stdout
    } = await this.execute(['profiles', 'list']);
    return JSON.parse(stdout);
  }

  async installProfile({
    profilePath,
    payload
  } = {}) {
    if (!profilePath && !payload) {
      throw new Error('Either the full path to the profile or its payload must be provided');
    }

    let tmpRoot;
    let srcPath = profilePath;

    try {
      if (!srcPath) {
        tmpRoot = await _support.tempDir.openDir();
        srcPath = _path.default.join(tmpRoot, 'cert.pem');
        await _support.fs.writeFile(srcPath, payload, 'utf8');
      }

      await this.execute(['profiles', 'install', '--path', srcPath], {
        logStdout: true
      });
    } finally {
      if (tmpRoot) {
        await _support.fs.rimraf(tmpRoot);
      }
    }
  }

  async removeProfile(name) {
    await this.execute(['profiles', 'remove', name], {
      logStdout: true
    });
  }

  async listCrashes() {
    const {
      stdout
    } = await this.execute(['crash', 'list']);
    return JSON.parse(stdout.replace(/'/g, '"')).filter(x => !['.', '..'].includes(x));
  }

  async exportCrash(name, dstFolder) {
    await this.execute(['crash', 'export', '--name', name], {
      logStdout: true,
      cwd: dstFolder
    });
  }

  async collectPcap(dstFile) {
    return await this.execute(['pcapd', dstFile], {
      format: null,
      asynchronous: true
    });
  }

}

exports.Pyidevice = Pyidevice;
var _default = Pyidevice;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9weS1pb3MtZGV2aWNlLWNsaWVudC5qcyJdLCJuYW1lcyI6WyJCSU5BUllfTkFNRSIsIlB5aWRldmljZSIsImNvbnN0cnVjdG9yIiwidWRpZCIsImJpbmFyeVBhdGgiLCJhc3NlcnRFeGlzdHMiLCJpc1N0cmljdCIsImZzIiwid2hpY2giLCJlIiwiRXJyb3IiLCJleGVjdXRlIiwiYXJncyIsIm9wdHMiLCJjd2QiLCJmb3JtYXQiLCJsb2dTdGRvdXQiLCJhc3luY2hyb25vdXMiLCJmaW5hbEFyZ3MiLCJwdXNoIiwiY21kU3RyIiwidXRpbCIsInF1b3RlIiwibG9nIiwiZGVidWciLCJyZXN1bHQiLCJTdWJQcm9jZXNzIiwic3RhcnQiLCJzdGRvdXQiLCJzdGRlcnIiLCJtZXNzYWdlIiwibGlzdFByb2ZpbGVzIiwiSlNPTiIsInBhcnNlIiwiaW5zdGFsbFByb2ZpbGUiLCJwcm9maWxlUGF0aCIsInBheWxvYWQiLCJ0bXBSb290Iiwic3JjUGF0aCIsInRlbXBEaXIiLCJvcGVuRGlyIiwicGF0aCIsImpvaW4iLCJ3cml0ZUZpbGUiLCJyaW1yYWYiLCJyZW1vdmVQcm9maWxlIiwibmFtZSIsImxpc3RDcmFzaGVzIiwicmVwbGFjZSIsImZpbHRlciIsIngiLCJpbmNsdWRlcyIsImV4cG9ydENyYXNoIiwiZHN0Rm9sZGVyIiwiY29sbGVjdFBjYXAiLCJkc3RGaWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUlBLE1BQU1BLFdBQVcsR0FBRyxXQUFwQjs7QUFFQSxNQUFNQyxTQUFOLENBQWdCO0FBQ2RDLEVBQUFBLFdBQVcsQ0FBRUMsSUFBRixFQUFRO0FBQ2pCLFNBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUtDLFVBQUwsR0FBa0IsSUFBbEI7QUFDRDs7QUFFaUIsUUFBWkMsWUFBWSxDQUFFQyxRQUFRLEdBQUcsSUFBYixFQUFtQjtBQUNuQyxRQUFJLEtBQUtGLFVBQVQsRUFBcUI7QUFDbkIsYUFBTyxJ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LENBQU47QUFLRDs7QUFFZ0IsUUFBWEMsV0FBVyxDQUFFQyxPQUFGLEVBQVc7QUFDMUIsV0FBTyxNQUFNLEtBQUs1QyxPQUFMLENBQWEsQ0FBQyxPQUFELEVBQVU0QyxPQUFWLENBQWIsRUFBaUM7QUFDNUN4QyxNQUFBQSxNQUFNLEVBQUUsSUFEb0M7QUFFNUNFLE1BQUFBLFlBQVksRUFBRTtBQUY4QixLQUFqQyxDQUFiO0FBSUQ7O0FBekdhOzs7ZUE2R0RoQixTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhlYywgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyBmcywgdXRpbCwgdGVtcERpciB9IGZyb20gJ0BhcHBpdW0vc3VwcG9ydCc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vWXVlQ2hlbi1DL3B5LWlvcy1kZXZpY2VcblxuY29uc3QgQklOQVJZX05BTUUgPSAncHlpZGV2aWNlJztcblxuY2xhc3MgUHlpZGV2aWNlIHtcbiAgY29uc3RydWN0b3IgKHVkaWQpIHtcbiAgICB0aGlzLnVkaWQgPSB1ZGlkO1xuICAgIHRoaXMuYmluYXJ5UGF0aCA9IG51bGw7XG4gIH1cblxuICBhc3luYyBhc3NlcnRFeGlzdHMgKGlzU3RyaWN0ID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmJpbmFyeVBhdGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLmJpbmFyeVBhdGggPSBhd2FpdCBmcy53aGljaChCSU5BUllfTkFNRSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0JJTkFSWV9OQU1FfSBiaW5hcnkgY2Fubm90IGJlIGZvdW5kIGluIFBBVEguIGAgK1xuICAgICAgICAgIGBQbGVhc2UgbWFrZSBzdXJlIGl0IGlzIGluc3RhbGxlZC4gVmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL1l1ZUNoZW4tQy9weS1pb3MtZGV2aWNlIGZvciBgICtcbiAgICAgICAgICBgbW9yZSBkZXRhaWxzLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGUgKGFyZ3MsIG9wdHMgPSB7fSkge1xuICAgIGF3YWl0IHRoaXMuYXNzZXJ0RXhpc3RzKCk7XG4gICAgY29uc3Qge1xuICAgICAgY3dkLFxuICAgICAgZm9ybWF0ID0gJ2pzb24nLFxuICAgICAgbG9nU3Rkb3V0ID0gZmFsc2UsXG4gICAgICBhc3luY2hyb25vdXMgPSBmYWxzZSxcbiAgICB9ID0gb3B0cztcblxuICAgIGNvbnN0IGZpbmFsQXJncyA9IFsuLi5hcmdzLCAnLS11ZGlkJywgdGhpcy51ZGlkXTtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBmaW5hbEFyZ3MucHVzaCgnLS1mb3JtYXQnLCBmb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBjbWRTdHIgPSB1dGlsLnF1b3RlKFt0aGlzLmJpbmFyeVBhdGgsIC4uLmZpbmFsQXJnc10pO1xuICAgIGxvZy5kZWJ1ZyhgRXhlY3V0aW5nICR7Y21kU3RyfWApO1xuICAgIHRyeSB7XG4gICAgICBpZiAoYXN5bmNocm9ub3VzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTdWJQcm9jZXNzKHRoaXMuYmluYXJ5UGF0aCwgZmluYWxBcmdzLCB7Y3dkfSk7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5zdGFydCgwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWModGhpcy5iaW5hcnlQYXRoLCBmaW5hbEFyZ3MsIHtjd2R9KTtcbiAgICAgIGlmIChsb2dTdGRvdXQpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBDb21tYW5kIG91dHB1dDogJHtyZXN1bHQuc3Rkb3V0fWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2NtZFN0cn0nIGZhaWxlZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5zdGRlcnIgfHwgZS5zdGRvdXQgfHwgZS5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGxpc3RQcm9maWxlcyAoKSB7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCB0aGlzLmV4ZWN1dGUoWydwcm9maWxlcycsICdsaXN0J10pO1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0ZG91dCk7XG4gIH1cblxuICBhc3luYyBpbnN0YWxsUHJvZmlsZSAoe3Byb2ZpbGVQYXRoLCBwYXlsb2FkfSA9IHt9KSB7XG4gICAgaWYgKCFwcm9maWxlUGF0aCAmJiAhcGF5bG9hZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFaXRoZXIgdGhlIGZ1bGwgcGF0aCB0byB0aGUgcHJvZmlsZSBvciBpdHMgcGF5bG9hZCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgbGV0IHRtcFJvb3Q7XG4gICAgbGV0IHNyY1BhdGggPSBwcm9maWxlUGF0aDtcbiAgICB0cnkge1xuICAgICAgaWYgKCFzcmNQYXRoKSB7XG4gICAgICAgIHRtcFJvb3QgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgICAgICAgc3JjUGF0aCA9IHBhdGguam9pbih0bXBSb290LCAnY2VydC5wZW0nKTtcbiAgICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHNyY1BhdGgsIHBheWxvYWQsICd1dGY4Jyk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmV4ZWN1dGUoWydwcm9maWxlcycsICdpbnN0YWxsJywgJy0tcGF0aCcsIHNyY1BhdGhdLCB7XG4gICAgICAgIGxvZ1N0ZG91dDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0bXBSb290KSB7XG4gICAgICAgIGF3YWl0IGZzLnJpbXJhZih0bXBSb290KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyByZW1vdmVQcm9maWxlIChuYW1lKSB7XG4gICAgYXdhaXQgdGhpcy5leGVjdXRlKFsncHJvZmlsZXMnLCAncmVtb3ZlJywgbmFtZV0sIHtsb2dTdGRvdXQ6IHRydWV9KTtcbiAgfVxuXG4gIGFzeW5jIGxpc3RDcmFzaGVzICgpIHtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHRoaXMuZXhlY3V0ZShbJ2NyYXNoJywgJ2xpc3QnXSk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3Rkb3V0LnJlcGxhY2UoLycvZywgJ1wiJykpLmZpbHRlcigoeCkgPT4gIVsnLicsICcuLiddLmluY2x1ZGVzKHgpKTtcbiAgfVxuXG4gIGFzeW5jIGV4cG9ydENyYXNoIChuYW1lLCBkc3RGb2xkZXIpIHtcbiAgICBhd2FpdCB0aGlzLmV4ZWN1dGUoWydjcmFzaCcsICdleHBvcnQnLCAnLS1uYW1lJywgbmFtZV0sIHtcbiAgICAgIGxvZ1N0ZG91dDogdHJ1ZSxcbiAgICAgIC8vIFRoZSB0b29sIGV4cG9ydHMgY3Jhc2ggcmVwb3J0cyB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpclxuICAgICAgY3dkOiBkc3RGb2xkZXJcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGNvbGxlY3RQY2FwIChkc3RGaWxlKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZShbJ3BjYXBkJywgZHN0RmlsZV0sIHtcbiAgICAgIGZvcm1hdDogbnVsbCxcbiAgICAgIGFzeW5jaHJvbm91czogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7IFB5aWRldmljZSB9O1xuZXhwb3J0IGRlZmF1bHQgUHlpZGV2aWNlO1xuIl0sImZpbGUiOiJsaWIvcHktaW9zLWRldmljZS1jbGllbnQuanMiLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
