"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.commands = void 0;
exports.parseContainerPath = parseContainerPath;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _support = require("@appium/support");

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("../logger"));

var _appiumIosDevice = require("appium-ios-device");

var _iosFsHelpers = require("../ios-fs-helpers");

const CONTAINER_PATH_MARKER = '@';
const CONTAINER_PATH_PATTERN = new RegExp(`^${CONTAINER_PATH_MARKER}([^/]+)/(.*)`);
const CONTAINER_TYPE_SEPARATOR = ':';
const CONTAINER_DOCUMENTS_PATH = 'Documents';
const OBJECT_NOT_FOUND_ERROR_MESSAGE = 'OBJECT_NOT_FOUND';
const commands = {};
exports.commands = commands;

function verifyIsSubPath(originalPath, root) {
  const normalizedRoot = _path.default.normalize(root);

  const normalizedPath = _path.default.normalize(_path.default.dirname(originalPath));

  if (normalizedRoot !== originalPath && !normalizedPath.startsWith(normalizedRoot)) {
    _logger.default.errorAndThrow(`'${normalizedPath}' is expected to be a subpath of '${normalizedRoot}'`);
  }
}

async function createAfcClient(udid, bundleId, containerType) {
  if (!bundleId) {
    return await _appiumIosDevice.services.startAfcService(udid);
  }

  const service = await _appiumIosDevice.services.startHouseArrestService(udid);
  return isDocumentsContainer(containerType) ? await service.vendDocuments(bundleId) : await service.vendContainer(bundleId);
}

function isDocumentsContainer(containerType) {
  return _lodash.default.toLower(containerType) === _lodash.default.toLower(CONTAINER_DOCUMENTS_PATH);
}

async function createService(udid, remotePath) {
  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer,
      containerType
    } = await parseContainerPath(remotePath);
    const service = await createAfcClient(udid, bundleId, containerType);
    const relativePath = isDocumentsContainer(containerType) ? _path.default.join(CONTAINER_DOCUMENTS_PATH, pathInContainer) : pathInContainer;
    return {
      service,
      relativePath
    };
  } else {
    const service = await createAfcClient(udid);
    return {
      service,
      relativePath: remotePath
    };
  }
}

async function parseContainerPath(remotePath, containerRootSupplier) {
  const match = CONTAINER_PATH_PATTERN.exec(remotePath);

  if (!match) {
    _logger.default.errorAndThrow(`It is expected that package identifier ` + `starts with '${CONTAINER_PATH_MARKER}' and is separated from the ` + `relative path with a single slash. '${remotePath}' is given instead`);
  }

  let [, bundleId, relativePath] = match;
  let containerType = null;
  const typeSeparatorPos = bundleId.indexOf(CONTAINER_TYPE_SEPARATOR);

  if (typeSeparatorPos > 0 && typeSeparatorPos < bundleId.length - 1) {
    containerType = bundleId.substring(typeSeparatorPos + 1);

    _logger.default.debug(`Parsed container type: ${containerType}`);

    bundleId = bundleId.substring(0, typeSeparatorPos);
  }

  if (_lodash.default.isNil(containerRootSupplier)) {
    const pathInContainer = relativePath;
    return {
      bundleId,
      pathInContainer,
      containerType
    };
  }

  const containerRoot = _lodash.default.isFunction(containerRootSupplier) ? await containerRootSupplier(bundleId, containerType) : containerRootSupplier;

  const pathInContainer = _path.default.posix.resolve(containerRoot, relativePath);

  verifyIsSubPath(pathInContainer, containerRoot);
  return {
    bundleId,
    pathInContainer,
    containerType
  };
}

async function pushFileToSimulator(device, remotePath, base64Data) {
  const buffer = Buffer.from(base64Data, 'base64');

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will put the data into '${dstPath}'`);

    if (!(await _support.fs.exists(_path.default.dirname(dstPath)))) {
      _logger.default.debug(`The destination folder '${_path.default.dirname(dstPath)}' does not exist. Creating...`);

      await (0, _support.mkdirp)(_path.default.dirname(dstPath));
    }

    await _support.fs.writeFile(dstPath, buffer);
    return;
  }

  const dstFolder = await _support.tempDir.openDir();

  const dstPath = _path.default.resolve(dstFolder, _path.default.basename(remotePath));

  try {
    await _support.fs.writeFile(dstPath, buffer);
    await device.simctl.addMedia(dstPath);
  } finally {
    await _support.fs.rimraf(dstFolder);
  }
}

async function pushFileToRealDevice(device, remotePath, base64Data) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    await (0, _iosFsHelpers.pushFile)(service, relativePath, base64Data);
  } catch (e) {
    _logger.default.debug(e.stack);

    throw new Error(`Could not push the file to '${remotePath}'.  Original error: ${e.message}`);
  } finally {
    service.close();
  }
}

async function deleteFileOrFolder(device, remotePath, isSimulator) {
  return isSimulator ? await deleteFromSimulator(device, remotePath) : await deleteFromRealDevice(device, remotePath);
}

async function pullFromSimulator(device, remotePath, isFile) {
  let pathOnServer;

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will get the data from '${dstPath}'`);

    pathOnServer = dstPath;
  } else {
    const simRoot = device.getDir();
    pathOnServer = _path.default.posix.join(simRoot, remotePath);
    verifyIsSubPath(pathOnServer, simRoot);

    _logger.default.info(`Got the full item path: ${pathOnServer}`);
  }

  if (!(await _support.fs.exists(pathOnServer))) {
    _logger.default.errorAndThrow(`The remote ${isFile ? 'file' : 'folder'} at '${pathOnServer}' does not exist`);
  }

  const buffer = isFile ? await _support.util.toInMemoryBase64(pathOnServer) : await _support.zip.toInMemoryZip(pathOnServer, {
    encodeToBase64: true
  });
  return buffer.toString();
}

async function pullFromRealDevice(device, remotePath, isFile) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    const fileInfo = await service.getFileInfo(relativePath);

    if (isFile && fileInfo.isDirectory()) {
      throw new Error(`The requested path is not a file. Path: '${remotePath}'`);
    }

    if (!isFile && !fileInfo.isDirectory()) {
      throw new Error(`The requested path is not a folder. Path: '${remotePath}'`);
    }

    return fileInfo.isFile() ? (await (0, _iosFsHelpers.pullFile)(service, relativePath)).toString('base64') : (await (0, _iosFsHelpers.pullFolder)(service, relativePath)).toString();
  } finally {
    service.close();
  }
}

async function deleteFromSimulator(device, remotePath) {
  let pathOnServer;

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `'${dstPath}' will be deleted`);

    pathOnServer = dstPath;
  } else {
    const simRoot = device.getDir();
    pathOnServer = _path.default.posix.join(simRoot, remotePath);
    verifyIsSubPath(pathOnServer, simRoot);

    _logger.default.info(`Got the full path: ${pathOnServer}`);
  }

  if (!(await _support.fs.exists(pathOnServer))) {
    _logger.default.errorAndThrow(`The remote path at '${pathOnServer}' does not exist`);
  }

  await _support.fs.rimraf(pathOnServer);
}

async function deleteFromRealDevice(device, remotePath) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    await service.deleteDirectory(relativePath);
  } catch (e) {
    if (e.message.includes(OBJECT_NOT_FOUND_ERROR_MESSAGE)) {
      throw new Error(`Path '${remotePath}' does not exist on the device`);
    }

    throw e;
  } finally {
    service.close();
  }
}

commands.pushFile = async function pushFile(remotePath, base64Data) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  if (_lodash.default.isArray(base64Data)) {
    base64Data = Buffer.from(base64Data).toString('utf8');
  }

  return this.isSimulator() ? await pushFileToSimulator(this.opts.device, remotePath, base64Data) : await pushFileToRealDevice(this.opts.device, remotePath, base64Data);
};

commands.pullFile = async function pullFile(remotePath) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, true) : await pullFromRealDevice(this.opts.device, remotePath, true);
};

commands.mobileDeleteFolder = async function mobileDeleteFolder(opts = {}) {
  let {
    remotePath
  } = opts;

  if (!remotePath.endsWith('/')) {
    remotePath = `${remotePath}/`;
  }

  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());
};

commands.mobileDeleteFile = async function mobileDeleteFile(opts = {}) {
  const {
    remotePath
  } = opts;

  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());
};

commands.pullFolder = async function pullFolder(remotePath) {
  if (!remotePath.endsWith('/')) {
    remotePath = `${remotePath}/`;
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, false) : await pullFromRealDevice(this.opts.device, remotePath, false);
};

var _default = commands;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9maWxlLW1vdmVtZW50LmpzIl0sIm5hbWVzIjpbIkNPTlRBSU5FUl9QQVRIX01BUktFUiIsIkNPTlRBSU5FUl9QQVRIX1BBVFRFUk4iLCJSZWdFeHAiLCJDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IiLCJDT05UQUlORVJfRE9DVU1FTlRTX1BBVEgiLCJPQkpFQ1RfTk9UX0ZPVU5EX0VSUk9SX01FU1NBR0UiLCJjb21tYW5kcyIsInZlcmlmeUlzU3ViUGF0aCIsIm9yaWdpbmFsUGF0aCIsInJvb3QiLCJub3JtYWxpemVkUm9vdCIsInBhdGgiLCJub3JtYWxpemUiLCJub3JtYWxpemVkUGF0aCIsImRpcm5hbWUiLCJzdGFydHNXaXRoIiwibG9nIiwiZXJyb3JBbmRUaHJvdyIsImNyZWF0ZUFmY0NsaWVudCIsInVkaWQiLCJidW5kbGVJZCIsImNvbnRhaW5lclR5cGUiLCJzZXJ2aWNlcyIsInN0YXJ0QWZjU2VydmljZSIsInNlcnZpY2UiLCJzdGFydEhvdXNlQXJyZXN0U2VydmljZSIsImlzRG9jdW1lbnRzQ29udGFpbmVyIiwidmVuZERvY3VtZW50cyIsInZlbmRDb250YWluZXIiLCJfIiwidG9Mb3dlciIsImNyZWF0ZVNlcnZpY2UiLCJyZW1vdGVQYXRoIiwidGVzdCIsInBhdGhJbkNvbnRhaW5lciIsInBhcnNlQ29udGFpbmVyUGF0aCIsInJlbGF0aXZlUGF0aCIsImpvaW4iLCJjb250YWluZXJSb290U3VwcGxpZXIiLCJtYXRjaCIsImV4ZWMiLCJ0eXBlU2VwYXJhdG9yUG9zIiwiaW5kZXhPZiIsImxlbmd0aCIsInN1YnN0cmluZyIsImRlYnVnIiwiaXNOaWwiLCJjb250YWluZXJSb290IiwiaXNGdW5jdGlvbiIsInBvc2l4IiwicmVzb2x2ZSIsInB1c2hGaWxlVG9TaW11bGF0b3IiLCJkZXZpY2UiLCJiYXNlNjREYXRhIiwiYnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsImRzdFBhdGgiLCJhcHBCdW5kbGUiLCJzaW1jdGwiLCJnZXRBcHBDb250YWluZXIiLCJpbmZvIiwiZnMiLCJleGlzdHMiLCJ3cml0ZUZpbGUiLCJkc3RGb2xkZXIiLCJ0ZW1wRGlyIiwib3BlbkRpciIsImJhc2VuYW1lIiwiYWRkTWVkaWEiLCJyaW1yYWYiLCJwdXNoRmlsZVRvUmVhbERldmljZSIsImUiLCJzdGFjayIsIkVycm9yIiwibWVzc2FnZSIsImNsb3NlIiwiZGVsZXRlRmlsZU9yRm9sZGVyIiwiaXNTaW11bGF0b3IiLCJkZWxldGVGcm9tU2ltdWxhdG9yIiwiZGVsZXRlRnJvbVJlYWxEZXZpY2UiLCJwdWxsRnJvbVNpbXVsYXRvciIsImlzRmlsZSIsInBhdGhPblNlcnZlciIsInNpbVJvb3QiLCJnZXREaXIiLCJ1dGlsIiwidG9Jbk1lbW9yeUJhc2U2NCIsInppcCIsInRvSW5NZW1vcnlaaXAiLCJlbmNvZGVUb0Jhc2U2NCIsInRvU3RyaW5nIiwicHVsbEZyb21SZWFsRGV2aWNlIiwiZmlsZUluZm8iLCJnZXRGaWxlSW5mbyIsImlzRGlyZWN0b3J5IiwiZGVsZXRlRGlyZWN0b3J5IiwiaW5jbHVkZXMiLCJwdXNoRmlsZSIsImVuZHNXaXRoIiwiaXNBcnJheSIsIm9wdHMiLCJwdWxsRmlsZSIsIm1vYmlsZURlbGV0ZUZvbGRlciIsIm1vYmlsZURlbGV0ZUZpbGUiLCJwdWxsRm9sZGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNQSxxQkFBcUIsR0FBRyxHQUE5QjtBQUVBLE1BQU1DLHNCQUFzQixHQUFHLElBQUlDLE1BQUosQ0FBWSxJQUFHRixxQkFBc0IsY0FBckMsQ0FBL0I7QUFDQSxNQUFNRyx3QkFBd0IsR0FBRyxHQUFqQztBQUNBLE1BQU1DLHdCQUF3QixHQUFHLFdBQWpDO0FBQ0EsTUFBTUMsOEJBQThCLEdBQUcsa0JBQXZDO0FBRUEsTUFBTUMsUUFBUSxHQUFHLEVBQWpCOzs7QUFFQSxTQUFTQyxlQUFULENBQTBCQyxZQUExQixFQUF3Q0MsSUFBeEMsRUFBOEM7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QUdELENBUEQ7O2VBVWUxQixRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGZzLCB0ZW1wRGlyLCBta2RpcnAsIHppcCwgdXRpbCB9IGZyb20gJ0BhcHBpdW0vc3VwcG9ydCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IHNlcnZpY2VzIH0gZnJvbSAnYXBwaXVtLWlvcy1kZXZpY2UnO1xuaW1wb3J0IHsgcHVsbEZpbGUsIHB1bGxGb2xkZXIsIHB1c2hGaWxlIH0gZnJvbSAnLi4vaW9zLWZzLWhlbHBlcnMnO1xuXG5jb25zdCBDT05UQUlORVJfUEFUSF9NQVJLRVIgPSAnQCc7XG4vLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL1BMZEIwRy8yXG5jb25zdCBDT05UQUlORVJfUEFUSF9QQVRURVJOID0gbmV3IFJlZ0V4cChgXiR7Q09OVEFJTkVSX1BBVEhfTUFSS0VSfShbXi9dKykvKC4qKWApO1xuY29uc3QgQ09OVEFJTkVSX1RZUEVfU0VQQVJBVE9SID0gJzonO1xuY29uc3QgQ09OVEFJTkVSX0RPQ1VNRU5UU19QQVRIID0gJ0RvY3VtZW50cyc7XG5jb25zdCBPQkpFQ1RfTk9UX0ZPVU5EX0VSUk9SX01FU1NBR0UgPSAnT0JKRUNUX05PVF9GT1VORCc7XG5cbmNvbnN0IGNvbW1hbmRzID0ge307XG5cbmZ1bmN0aW9uIHZlcmlmeUlzU3ViUGF0aCAob3JpZ2luYWxQYXRoLCByb290KSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRSb290ID0gcGF0aC5ub3JtYWxpemUocm9vdCk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gcGF0aC5ub3JtYWxpemUocGF0aC5kaXJuYW1lKG9yaWdpbmFsUGF0aCkpO1xuICAvLyBJZiBvcmlnaW5hbFBhdGggaXMgcm9vdCwgYC9gLCBvcmlnaW5hbFBhdGggc2hvdWxkIGVxdWFsIHRvIG5vcm1hbGl6ZWRSb290XG4gIGlmIChub3JtYWxpemVkUm9vdCAhPT0gb3JpZ2luYWxQYXRoICYmICFub3JtYWxpemVkUGF0aC5zdGFydHNXaXRoKG5vcm1hbGl6ZWRSb290KSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGAnJHtub3JtYWxpemVkUGF0aH0nIGlzIGV4cGVjdGVkIHRvIGJlIGEgc3VicGF0aCBvZiAnJHtub3JtYWxpemVkUm9vdH0nYCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQWZjQ2xpZW50ICh1ZGlkLCBidW5kbGVJZCwgY29udGFpbmVyVHlwZSkge1xuICBpZiAoIWJ1bmRsZUlkKSB7XG4gICAgcmV0dXJuIGF3YWl0IHNlcnZpY2VzLnN0YXJ0QWZjU2VydmljZSh1ZGlkKTtcbiAgfVxuICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgc2VydmljZXMuc3RhcnRIb3VzZUFycmVzdFNlcnZpY2UodWRpZCk7XG4gIHJldHVybiBpc0RvY3VtZW50c0NvbnRhaW5lcihjb250YWluZXJUeXBlKVxuICAgID8gYXdhaXQgc2VydmljZS52ZW5kRG9jdW1lbnRzKGJ1bmRsZUlkKVxuICAgIDogYXdhaXQgc2VydmljZS52ZW5kQ29udGFpbmVyKGJ1bmRsZUlkKTtcbn1cblxuZnVuY3Rpb24gaXNEb2N1bWVudHNDb250YWluZXIgKGNvbnRhaW5lclR5cGUpIHtcbiAgcmV0dXJuIF8udG9Mb3dlcihjb250YWluZXJUeXBlKSA9PT0gXy50b0xvd2VyKENPTlRBSU5FUl9ET0NVTUVOVFNfUEFUSCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNlcnZpY2UgKHVkaWQsIHJlbW90ZVBhdGgpIHtcbiAgaWYgKENPTlRBSU5FUl9QQVRIX1BBVFRFUk4udGVzdChyZW1vdGVQYXRoKSkge1xuICAgIGNvbnN0IHtidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyLCBjb250YWluZXJUeXBlfSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoKTtcbiAgICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgY3JlYXRlQWZjQ2xpZW50KHVkaWQsIGJ1bmRsZUlkLCBjb250YWluZXJUeXBlKTtcbiAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBpc0RvY3VtZW50c0NvbnRhaW5lcihjb250YWluZXJUeXBlKVxuICAgICAgPyBwYXRoLmpvaW4oQ09OVEFJTkVSX0RPQ1VNRU5UU19QQVRILCBwYXRoSW5Db250YWluZXIpXG4gICAgICA6IHBhdGhJbkNvbnRhaW5lcjtcbiAgICByZXR1cm4ge3NlcnZpY2UsIHJlbGF0aXZlUGF0aH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2VydmljZSA9IGF3YWl0IGNyZWF0ZUFmY0NsaWVudCh1ZGlkKTtcbiAgICByZXR1cm4ge3NlcnZpY2UsIHJlbGF0aXZlUGF0aDogcmVtb3RlUGF0aH07XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb250YWluZXJPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYnVuZGxlSWQgLSBUaGUgcGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF0aEluQ29udGFpbmVyIC0gVGhlIGFic29sdXRlIGZ1bGwgcGF0aCBvZiB0aGUgaXRlbSBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW1cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gY29udGFpbmVyVHlwZSAtIFRoZSBjb250YWluZXIgdHlwZVxuICovXG5cbi8qKlxuICogUGFyc2VzIHRoZSBhY3R1YWwgcGF0aCBhbmQgdGhlIGJ1bmRsZSBpZGVudGlmaWVyIGZyb20gdGhlIGdpdmVuIHBhdGggc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgZ2l2ZW4gcGF0aCBzdHJpbmcuIFRoZSBzdHJpbmcgc2hvdWxkXG4gKiBtYXRjaCBgQ09OVEFJTkVSX1BBVEhfUEFUVEVSTmAgcmVnZXhwLCBvdGhlcndpc2UgYW4gZXJyb3IgaXMgZ29pbmdcbiAqIHRvIGJlIHRocm93bi4gQSB2YWxpZCBzdHJpbmcgZXhhbXBsZTogYEBidW5kbGUuaWRlbnRpZmllcjpjb250YWluZXJfdHlwZS9yZWxhdGl2ZV9wYXRoX2luX2NvbnRhaW5lcmBcbiAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBjb250YWluZXJSb290U3VwcGxpZXIgLSBFaXRoZXIgYSBzdHJpbmcsIHRoYXQgY29udGFpbnNcbiAqIGZ1bGwgcGF0aCB0byB0aGUgbW91bnQgcm9vdCBmb3IgcmVhbCBkZXZpY2VzIG9yIGEgZnVuY3Rpb24sIHdoaWNoIGFjY2VwdHMgdHdvIHBhcmFtZXRlcnNcbiAqIChidW5kbGUgaWRlbnRpZmllciBhbmQgb3B0aW9uYWwgY29udGFpbmVyIHR5cGUpIGFuZCByZXR1cm5zIGZ1bGwgcGF0aCB0byBjb250YWluZXJcbiAqIHJvb3QgZm9sZGVyIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbSwgZm9yIFNpbXVsYXRvclxuICogQHJldHVybnMge0NvbnRhaW5lck9iamVjdH1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VDb250YWluZXJQYXRoIChyZW1vdGVQYXRoLCBjb250YWluZXJSb290U3VwcGxpZXIpIHtcbiAgY29uc3QgbWF0Y2ggPSBDT05UQUlORVJfUEFUSF9QQVRURVJOLmV4ZWMocmVtb3RlUGF0aCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSXQgaXMgZXhwZWN0ZWQgdGhhdCBwYWNrYWdlIGlkZW50aWZpZXIgYCArXG4gICAgICBgc3RhcnRzIHdpdGggJyR7Q09OVEFJTkVSX1BBVEhfTUFSS0VSfScgYW5kIGlzIHNlcGFyYXRlZCBmcm9tIHRoZSBgICtcbiAgICAgIGByZWxhdGl2ZSBwYXRoIHdpdGggYSBzaW5nbGUgc2xhc2guICcke3JlbW90ZVBhdGh9JyBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgbGV0IFssIGJ1bmRsZUlkLCByZWxhdGl2ZVBhdGhdID0gbWF0Y2g7XG4gIGxldCBjb250YWluZXJUeXBlID0gbnVsbDtcbiAgY29uc3QgdHlwZVNlcGFyYXRvclBvcyA9IGJ1bmRsZUlkLmluZGV4T2YoQ09OVEFJTkVSX1RZUEVfU0VQQVJBVE9SKTtcbiAgLy8gV2Ugb25seSBjb25zaWRlciBjb250YWluZXIgdHlwZSBleGlzdHMgaWYgaXRzIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gemVyb1xuICAvLyBub3QgY291bnRpbmcgdGhlIGNvbG9uXG4gIGlmICh0eXBlU2VwYXJhdG9yUG9zID4gMCAmJiB0eXBlU2VwYXJhdG9yUG9zIDwgYnVuZGxlSWQubGVuZ3RoIC0gMSkge1xuICAgIGNvbnRhaW5lclR5cGUgPSBidW5kbGVJZC5zdWJzdHJpbmcodHlwZVNlcGFyYXRvclBvcyArIDEpO1xuICAgIGxvZy5kZWJ1ZyhgUGFyc2VkIGNvbnRhaW5lciB0eXBlOiAke2NvbnRhaW5lclR5cGV9YCk7XG4gICAgYnVuZGxlSWQgPSBidW5kbGVJZC5zdWJzdHJpbmcoMCwgdHlwZVNlcGFyYXRvclBvcyk7XG4gIH1cbiAgaWYgKF8uaXNOaWwoY29udGFpbmVyUm9vdFN1cHBsaWVyKSkge1xuICAgIGNvbnN0IHBhdGhJbkNvbnRhaW5lciA9IHJlbGF0aXZlUGF0aDtcbiAgICByZXR1cm4geyBidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyLCBjb250YWluZXJUeXBlIH07XG4gIH1cbiAgY29uc3QgY29udGFpbmVyUm9vdCA9IF8uaXNGdW5jdGlvbihjb250YWluZXJSb290U3VwcGxpZXIpXG4gICAgPyBhd2FpdCBjb250YWluZXJSb290U3VwcGxpZXIoYnVuZGxlSWQsIGNvbnRhaW5lclR5cGUpXG4gICAgOiBjb250YWluZXJSb290U3VwcGxpZXI7XG4gIGNvbnN0IHBhdGhJbkNvbnRhaW5lciA9IHBhdGgucG9zaXgucmVzb2x2ZShjb250YWluZXJSb290LCByZWxhdGl2ZVBhdGgpO1xuICB2ZXJpZnlJc1N1YlBhdGgocGF0aEluQ29udGFpbmVyLCBjb250YWluZXJSb290KTtcbiAgcmV0dXJuIHtidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyLCBjb250YWluZXJUeXBlfTtcbn1cblxuLyoqXG4gKiBTYXZlIHRoZSBnaXZlbiBiYXNlNjQgZGF0YSBjaHVuayBhcyBhIGJpbmFyeSBmaWxlIG9uIHRoZSBTaW11bGF0b3IgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIG9uIHRoZSBkZXZpY2UuIFRoaXMgdmFyaWFibGUgY2FuIGJlIHByZWZpeGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlIGlkLCBzbyB0aGVuIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLCBmb3IgZXhhbXBsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQGNvbS5teWFwcC5ibGE6ZGF0YS9SZWxhdGl2ZVBhdGhJbkNvbnRhaW5lci8xMTEucG5nJy4gVGhlICdAJyBjaGFyYWN0ZXIgYXQgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2lubmluZyBvZiB0aGUgYXJndW1lbnQgaXMgbWFuZGF0b3J5IGluIHN1Y2ggY2FzZS4gVGhlIGNvbG9uIGF0IHRoZSBlbmQgb2YgYnVuZGxlIGlkZW50aWZpZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgb3B0aW9uYWwgYW5kIGlzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggdGhlIGNvbnRhaW5lciB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3NzaWJsZSB2YWx1ZXMgdGhlcmUgYXJlICdhcHAnLCAnZGF0YScsICdncm91cHMnLCAnPEEgc3BlY2lmaWMgQXBwIEdyb3VwIGNvbnRhaW5lcj4nLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAnYXBwJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJlbGF0aXZlIGZvbGRlciBwYXRoIGlzIGlnbm9yZWQgaWYgdGhlIGZpbGUgaXMgZ29pbmcgdG8gYmUgdXBsb2FkZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyIGFuZCBvbmx5IHRoZSBmaWxlIG5hbWUgaXMgY29uc2lkZXJlZCBpbXBvcnRhbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0RGF0YSAtIEJhc2UtNjQgZW5jb2RlZCBjb250ZW50IG9mIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBwdXNoRmlsZVRvU2ltdWxhdG9yIChkZXZpY2UsIHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpIHtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYmFzZTY0RGF0YSwgJ2Jhc2U2NCcpO1xuICBpZiAoQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi50ZXN0KHJlbW90ZVBhdGgpKSB7XG4gICAgY29uc3Qge2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXI6IGRzdFBhdGh9ID0gYXdhaXQgcGFyc2VDb250YWluZXJQYXRoKHJlbW90ZVBhdGgsXG4gICAgICBhc3luYyAoYXBwQnVuZGxlLCBjb250YWluZXJUeXBlKSA9PiBhd2FpdCBkZXZpY2Uuc2ltY3RsLmdldEFwcENvbnRhaW5lcihhcHBCdW5kbGUsIGNvbnRhaW5lclR5cGUpKTtcbiAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgYFdpbGwgcHV0IHRoZSBkYXRhIGludG8gJyR7ZHN0UGF0aH0nYCk7XG4gICAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aC5kaXJuYW1lKGRzdFBhdGgpKSkge1xuICAgICAgbG9nLmRlYnVnKGBUaGUgZGVzdGluYXRpb24gZm9sZGVyICcke3BhdGguZGlybmFtZShkc3RQYXRoKX0nIGRvZXMgbm90IGV4aXN0LiBDcmVhdGluZy4uLmApO1xuICAgICAgYXdhaXQgbWtkaXJwKHBhdGguZGlybmFtZShkc3RQYXRoKSk7XG4gICAgfVxuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCBidWZmZXIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkc3RGb2xkZXIgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShkc3RGb2xkZXIsIHBhdGguYmFzZW5hbWUocmVtb3RlUGF0aCkpO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCBidWZmZXIpO1xuICAgIGF3YWl0IGRldmljZS5zaW1jdGwuYWRkTWVkaWEoZHN0UGF0aCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKGRzdEZvbGRlcik7XG4gIH1cbn1cblxuLyoqXG4gKiBTYXZlIHRoZSBnaXZlbiBiYXNlNjQgZGF0YSBjaHVuayBhcyBhIGJpbmFyeSBmaWxlIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIG9uIHRoZSBkZXZpY2UuIFRoaXMgdmFyaWFibGUgY2FuIGJlIHByZWZpeGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlIGlkLCBzbyB0aGVuIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLiBVc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPjo8b3B0aW9uYWxfY29udGFpbmVyX3R5cGU+LzxwYXRoX3RvX3RoZV9maWxlX29yX2ZvbGRlcl9pbnNpZGVfY29udGFpbmVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgdG8gcHVsbCBhIGZpbGUgb3IgYSBmb2xkZXIgZnJvbSBhbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvbmx5IHN1cHBvcnRlZCBjb250YWluZXIgdHlwZSBpcyAnZG9jdW1lbnRzJy4gSWYgdGhlIGNvbnRhaW5lciB0eXBlIGlzIG5vdCBzZXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwbGljaXRseSBmb3IgYSBidW5kbGUgaWQsIHRoZW4gdGhlIGRlZmF1bHQgYXBwbGljYXRpb24gY29udGFpbmVyIGlzIGdvaW5nIHRvIGJlIG1vdW50ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFrYSAtLWNvbnRhaW5lciBpZnVzZSBhcmd1bWVudClcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5nLiBJZiBgQGNvbS5teWFwcC5ibGE6ZG9jdW1lbnRzLzExMS5wbmdgIGlzIHByb3ZpZGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAgaW4gRmlsZXMgYXBwIHdpbGwgYmUgbW91bnRlZCBpbiB0aGUgaG9zdCBtYWNoaW5lLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJhc2U2NCBlbmNvZGVkIGAxMTEucG5nYCB3aWxsIGJlIHB1c2hlZCBpbnRvIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPi8xMTEucG5nYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIGJhc2U2NCBkZWNvZGVkIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0RGF0YSAtIEJhc2UtNjQgZW5jb2RlZCBjb250ZW50IG9mIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBwdXNoRmlsZVRvUmVhbERldmljZSAoZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKSB7XG4gIGNvbnN0IHtzZXJ2aWNlLCByZWxhdGl2ZVBhdGh9ID0gYXdhaXQgY3JlYXRlU2VydmljZShkZXZpY2UudWRpZCwgcmVtb3RlUGF0aCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgcHVzaEZpbGUoc2VydmljZSwgcmVsYXRpdmVQYXRoLCBiYXNlNjREYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5kZWJ1ZyhlLnN0YWNrKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwdXNoIHRoZSBmaWxlIHRvICcke3JlbW90ZVBhdGh9Jy4gIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXJ2aWNlLmNsb3NlKCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlRmlsZU9yRm9sZGVyIChkZXZpY2UsIHJlbW90ZVBhdGgsIGlzU2ltdWxhdG9yKSB7XG4gIHJldHVybiBpc1NpbXVsYXRvclxuICAgID8gYXdhaXQgZGVsZXRlRnJvbVNpbXVsYXRvcihkZXZpY2UsIHJlbW90ZVBhdGgpXG4gICAgOiBhd2FpdCBkZWxldGVGcm9tUmVhbERldmljZShkZXZpY2UsIHJlbW90ZVBhdGgpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY29udGVudCBvZiBnaXZlbiBmaWxlIG9yIGZvbGRlciBmcm9tIGlPUyBTaW11bGF0b3IgYW5kIHJldHVybiBpdCBhcyBiYXNlLTY0IGVuY29kZWQgc3RyaW5nLlxuICogRm9sZGVyIGNvbnRlbnQgaXMgcmVjdXJzaXZlbHkgcGFja2VkIGludG8gYSB6aXAgYXJjaGl2ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYSBmaWxlIG9yIGEgZm9sZGVyLCB3aGljaCBleGlzdHMgaW4gdGhlIGNvcnJlc3BvbmRpbmcgYXBwbGljYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyIG9uIFNpbXVsYXRvci4gVXNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEA8YXBwX2J1bmRsZV9pZD46PG9wdGlvbmFsX2NvbnRhaW5lcl90eXBlPi88cGF0aF90b190aGVfZmlsZV9vcl9mb2xkZXJfaW5zaWRlX2NvbnRhaW5lcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IHRvIHB1bGwgYSBmaWxlIG9yIGEgZm9sZGVyIGZyb20gYW4gYXBwbGljYXRpb24gY29udGFpbmVyIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3NzaWJsZSBjb250YWluZXIgdHlwZXMgYXJlICdhcHAnLCAnZGF0YScsICdncm91cHMnLCAnPEEgc3BlY2lmaWMgQXBwIEdyb3VwIGNvbnRhaW5lcj4nLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB0eXBlIGlzICdhcHAnLlxuICogQHBhcmFtIHtib29sZWFufSBpc0ZpbGUgLSBXaGV0aGVyIHRoZSBkZXN0aW5hdGlvbiBpdGVtIGlzIGEgZmlsZSBvciBhIGZvbGRlclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZS02NCBlbmNvZGVkIGNvbnRlbnQgb2YgdGhlIGZpbGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1bGxGcm9tU2ltdWxhdG9yIChkZXZpY2UsIHJlbW90ZVBhdGgsIGlzRmlsZSkge1xuICBsZXQgcGF0aE9uU2VydmVyO1xuICBpZiAoQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi50ZXN0KHJlbW90ZVBhdGgpKSB7XG4gICAgY29uc3Qge2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXI6IGRzdFBhdGh9ID0gYXdhaXQgcGFyc2VDb250YWluZXJQYXRoKHJlbW90ZVBhdGgsXG4gICAgICBhc3luYyAoYXBwQnVuZGxlLCBjb250YWluZXJUeXBlKSA9PiBhd2FpdCBkZXZpY2Uuc2ltY3RsLmdldEFwcENvbnRhaW5lcihhcHBCdW5kbGUsIGNvbnRhaW5lclR5cGUpKTtcbiAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgYFdpbGwgZ2V0IHRoZSBkYXRhIGZyb20gJyR7ZHN0UGF0aH0nYCk7XG4gICAgcGF0aE9uU2VydmVyID0gZHN0UGF0aDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzaW1Sb290ID0gZGV2aWNlLmdldERpcigpO1xuICAgIHBhdGhPblNlcnZlciA9IHBhdGgucG9zaXguam9pbihzaW1Sb290LCByZW1vdGVQYXRoKTtcbiAgICB2ZXJpZnlJc1N1YlBhdGgocGF0aE9uU2VydmVyLCBzaW1Sb290KTtcbiAgICBsb2cuaW5mbyhgR290IHRoZSBmdWxsIGl0ZW0gcGF0aDogJHtwYXRoT25TZXJ2ZXJ9YCk7XG4gIH1cbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aE9uU2VydmVyKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBUaGUgcmVtb3RlICR7aXNGaWxlID8gJ2ZpbGUnIDogJ2ZvbGRlcid9IGF0ICcke3BhdGhPblNlcnZlcn0nIGRvZXMgbm90IGV4aXN0YCk7XG4gIH1cbiAgY29uc3QgYnVmZmVyID0gaXNGaWxlXG4gICAgPyBhd2FpdCB1dGlsLnRvSW5NZW1vcnlCYXNlNjQocGF0aE9uU2VydmVyKVxuICAgIDogYXdhaXQgemlwLnRvSW5NZW1vcnlaaXAocGF0aE9uU2VydmVyLCB7ZW5jb2RlVG9CYXNlNjQ6IHRydWV9KTtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY29udGVudCBvZiBnaXZlbiBmaWxlIG9yIGZvbGRlciBmcm9tIHRoZSByZWFsIGRldmljZSB1bmRlciB0ZXN0IGFuZCByZXR1cm4gaXQgYXMgYmFzZS02NCBlbmNvZGVkIHN0cmluZy5cbiAqIEZvbGRlciBjb250ZW50IGlzIHJlY3Vyc2l2ZWx5IHBhY2tlZCBpbnRvIGEgemlwIGFyY2hpdmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRldmljZSAtIFRoZSBkZXZpY2Ugb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG9iamVjdCBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBgdWRpZGAgcHJvcGVydHkgY29udGFpbmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCBkZXZpY2UgSUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBwYXRoIHRvIGFuIGV4aXN0aW5nIHJlbW90ZSBmaWxlIG9uIHRoZSBkZXZpY2UuIFRoaXMgdmFyaWFibGUgY2FuIGJlIHByZWZpeGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlIGlkLCBzbyB0aGVuIHRoZSBmaWxlIHdpbGwgYmUgZG93bmxvYWRlZCBmcm9tIHRoZSBjb3JyZXNwb25kaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG1lZGlhIGZvbGRlci4gVXNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEA8YXBwX2J1bmRsZV9pZD46PG9wdGlvbmFsX2NvbnRhaW5lcl90eXBlPi88cGF0aF90b190aGVfZmlsZV9vcl9mb2xkZXJfaW5zaWRlX2NvbnRhaW5lcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IHRvIHB1bGwgYSBmaWxlIG9yIGEgZm9sZGVyIGZyb20gYW4gYXBwbGljYXRpb24gY29udGFpbmVyIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb25seSBzdXBwb3J0ZWQgY29udGFpbmVyIHR5cGUgaXMgJ2RvY3VtZW50cycuIElmIHRoZSBjb250YWluZXIgdHlwZSBpcyBub3Qgc2V0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0bHkgZm9yIGEgYnVuZGxlIGlkLCB0aGVuIHRoZSBkZWZhdWx0IGFwcGxpY2F0aW9uIGNvbnRhaW5lciBpcyBnb2luZyB0byBiZSBtb3VudGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChha2EgLS1jb250YWluZXIgaWZ1c2UgYXJndW1lbnQpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZy4gSWYgYEBjb20ubXlhcHAuYmxhOmRvY3VtZW50cy8xMTEucG5nYCBpcyBwcm92aWRlZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT24gTXkgaVBob25lLzxhcHAgbmFtZT5gIGluIEZpbGVzIGFwcCB3aWxsIGJlIG1vdW50ZWQgaW4gdGhlIGhvc3QgbWFjaGluZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT24gTXkgaVBob25lLzxhcHAgbmFtZT4vMTExLnBuZ2Agd2lsIGJlIHB1bGxlZCBpbnRvIHRoZSBtb3VudGVkIGhvc3QgbWFjaGluZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBBcHBpdW0gcmV0dXJucyB0aGUgZGF0YSBhcyBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgdG8gY2xpZW50LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBAY29tLm15YXBwLmJsYTpkb2N1bWVudHMvYCBtZWFucyBgT24gTXkgaVBob25lLzxhcHAgbmFtZT5gLlxuICogQHBhcmFtIHtib29sZWFufSBpc0ZpbGUgLSBXaGV0aGVyIHRoZSBkZXN0aW5hdGlvbiBpdGVtIGlzIGEgZmlsZSBvciBhIGZvbGRlclxuICogQHJldHVybiB7c3RyaW5nfSBCYXNlLTY0IGVuY29kZWQgY29udGVudCBvZiB0aGUgcmVtb3RlIGZpbGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHVsbEZyb21SZWFsRGV2aWNlIChkZXZpY2UsIHJlbW90ZVBhdGgsIGlzRmlsZSkge1xuICBjb25zdCB7c2VydmljZSwgcmVsYXRpdmVQYXRofSA9IGF3YWl0IGNyZWF0ZVNlcnZpY2UoZGV2aWNlLnVkaWQsIHJlbW90ZVBhdGgpO1xuICB0cnkge1xuICAgIGNvbnN0IGZpbGVJbmZvID0gYXdhaXQgc2VydmljZS5nZXRGaWxlSW5mbyhyZWxhdGl2ZVBhdGgpO1xuICAgIGlmIChpc0ZpbGUgJiYgZmlsZUluZm8uaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcmVxdWVzdGVkIHBhdGggaXMgbm90IGEgZmlsZS4gUGF0aDogJyR7cmVtb3RlUGF0aH0nYCk7XG4gICAgfVxuICAgIGlmICghaXNGaWxlICYmICFmaWxlSW5mby5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSByZXF1ZXN0ZWQgcGF0aCBpcyBub3QgYSBmb2xkZXIuIFBhdGg6ICcke3JlbW90ZVBhdGh9J2ApO1xuICAgIH1cblxuICAgIHJldHVybiBmaWxlSW5mby5pc0ZpbGUoKVxuICAgICAgPyAoYXdhaXQgcHVsbEZpbGUoc2VydmljZSwgcmVsYXRpdmVQYXRoKSkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICA6IChhd2FpdCBwdWxsRm9sZGVyKHNlcnZpY2UsIHJlbGF0aXZlUGF0aCkpLnRvU3RyaW5nKCk7XG4gIH0gZmluYWxseSB7XG4gICAgc2VydmljZS5jbG9zZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBmaWxlIG9yIGZvbGRlciBmcm9tIHRoZSBkZXZpY2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYSBmaWxlIG9yIGEgZm9sZGVyLCB3aGljaCBleGlzdHMgaW4gdGhlIGNvcnJlc3BvbmRpbmcgYXBwbGljYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyIG9uIFNpbXVsYXRvci4gVXNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEA8YXBwX2J1bmRsZV9pZD46PG9wdGlvbmFsX2NvbnRhaW5lcl90eXBlPi88cGF0aF90b190aGVfZmlsZV9vcl9mb2xkZXJfaW5zaWRlX2NvbnRhaW5lcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IHRvIHB1bGwgYSBmaWxlIG9yIGEgZm9sZGVyIGZyb20gYW4gYXBwbGljYXRpb24gY29udGFpbmVyIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3NzaWJsZSBjb250YWluZXIgdHlwZXMgYXJlICdhcHAnLCAnZGF0YScsICdncm91cHMnLCAnPEEgc3BlY2lmaWMgQXBwIEdyb3VwIGNvbnRhaW5lcj4nLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB0eXBlIGlzICdhcHAnLlxuICovXG5hc3luYyBmdW5jdGlvbiBkZWxldGVGcm9tU2ltdWxhdG9yIChkZXZpY2UsIHJlbW90ZVBhdGgpIHtcbiAgbGV0IHBhdGhPblNlcnZlcjtcbiAgaWYgKENPTlRBSU5FUl9QQVRIX1BBVFRFUk4udGVzdChyZW1vdGVQYXRoKSkge1xuICAgIGNvbnN0IHtidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyOiBkc3RQYXRofSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoLFxuICAgICAgYXN5bmMgKGFwcEJ1bmRsZSwgY29udGFpbmVyVHlwZSkgPT4gYXdhaXQgZGV2aWNlLnNpbWN0bC5nZXRBcHBDb250YWluZXIoYXBwQnVuZGxlLCBjb250YWluZXJUeXBlKSk7XG4gICAgbG9nLmluZm8oYFBhcnNlZCBidW5kbGUgaWRlbnRpZmllciAnJHtidW5kbGVJZH0nIGZyb20gJyR7cmVtb3RlUGF0aH0nLiBgICtcbiAgICAgIGAnJHtkc3RQYXRofScgd2lsbCBiZSBkZWxldGVkYCk7XG4gICAgcGF0aE9uU2VydmVyID0gZHN0UGF0aDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzaW1Sb290ID0gZGV2aWNlLmdldERpcigpO1xuICAgIHBhdGhPblNlcnZlciA9IHBhdGgucG9zaXguam9pbihzaW1Sb290LCByZW1vdGVQYXRoKTtcbiAgICB2ZXJpZnlJc1N1YlBhdGgocGF0aE9uU2VydmVyLCBzaW1Sb290KTtcbiAgICBsb2cuaW5mbyhgR290IHRoZSBmdWxsIHBhdGg6ICR7cGF0aE9uU2VydmVyfWApO1xuICB9XG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKHBhdGhPblNlcnZlcikpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVGhlIHJlbW90ZSBwYXRoIGF0ICcke3BhdGhPblNlcnZlcn0nIGRvZXMgbm90IGV4aXN0YCk7XG4gIH1cbiAgYXdhaXQgZnMucmltcmFmKHBhdGhPblNlcnZlcik7XG59XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBmaWxlIG9yIGZvbGRlciBmcm9tIHRoZSBkZXZpY2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYW4gZXhpc3RpbmcgcmVtb3RlIGZpbGUgb24gdGhlIGRldmljZS4gVGhpcyB2YXJpYWJsZSBjYW4gYmUgcHJlZml4ZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUgaWQsIHNvIHRoZW4gdGhlIGZpbGUgd2lsbCBiZSBkb3dubG9hZGVkIGZyb20gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLiBVc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPjo8b3B0aW9uYWxfY29udGFpbmVyX3R5cGU+LzxwYXRoX3RvX3RoZV9maWxlX29yX2ZvbGRlcl9pbnNpZGVfY29udGFpbmVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgdG8gcHVsbCBhIGZpbGUgb3IgYSBmb2xkZXIgZnJvbSBhbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvbmx5IHN1cHBvcnRlZCBjb250YWluZXIgdHlwZSBpcyAnZG9jdW1lbnRzJy4gSWYgdGhlIGNvbnRhaW5lciB0eXBlIGlzIG5vdCBzZXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwbGljaXRseSBmb3IgYSBidW5kbGUgaWQsIHRoZW4gdGhlIGRlZmF1bHQgYXBwbGljYXRpb24gY29udGFpbmVyIGlzIGdvaW5nIHRvIGJlIG1vdW50ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFrYSAtLWNvbnRhaW5lciBpZnVzZSBhcmd1bWVudClcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5nLiBJZiBgQGNvbS5teWFwcC5ibGE6ZG9jdW1lbnRzLzExMS5wbmdgIGlzIHByb3ZpZGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAgaW4gRmlsZXMgYXBwIHdpbGwgYmUgbW91bnRlZCBpbiB0aGUgaG9zdCBtYWNoaW5lLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPi8xMTEucG5nYCB3aWwgYmUgcHVsbGVkIGludG8gdGhlIG1vdW50ZWQgaG9zdCBtYWNoaW5lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIEFwcGl1bSByZXR1cm5zIHRoZSBkYXRhIGFzIGJhc2U2NC1lbmNvZGVkIHN0cmluZyB0byBjbGllbnQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEBjb20ubXlhcHAuYmxhOmRvY3VtZW50cy9gIG1lYW5zIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUZyb21SZWFsRGV2aWNlIChkZXZpY2UsIHJlbW90ZVBhdGgpIHtcbiAgY29uc3QgeyBzZXJ2aWNlLCByZWxhdGl2ZVBhdGggfSA9IGF3YWl0IGNyZWF0ZVNlcnZpY2UoZGV2aWNlLnVkaWQsIHJlbW90ZVBhdGgpO1xuICB0cnkge1xuICAgIGF3YWl0IHNlcnZpY2UuZGVsZXRlRGlyZWN0b3J5KHJlbGF0aXZlUGF0aCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5tZXNzYWdlLmluY2x1ZGVzKE9CSkVDVF9OT1RfRk9VTkRfRVJST1JfTUVTU0FHRSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGF0aCAnJHtyZW1vdGVQYXRofScgZG9lcyBub3QgZXhpc3Qgb24gdGhlIGRldmljZWApO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9IGZpbmFsbHkge1xuICAgIHNlcnZpY2UuY2xvc2UoKTtcbiAgfVxufVxuXG5jb21tYW5kcy5wdXNoRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIHB1c2hGaWxlIChyZW1vdGVQYXRoLCBiYXNlNjREYXRhKSB7XG4gIGlmIChyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSXQgaXMgZXhwZWN0ZWQgdGhhdCByZW1vdGUgcGF0aCBwb2ludHMgdG8gYSBmaWxlIGFuZCBub3QgdG8gYSBmb2xkZXIuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGAnJHtyZW1vdGVQYXRofScgaXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIGlmIChfLmlzQXJyYXkoYmFzZTY0RGF0YSkpIHtcbiAgICAvLyBzb21lIGNsaWVudHMgKGFoZW0pIGphdmEsIHNlbmQgYSBieXRlIGFycmF5IGVuY29kaW5nIHV0ZjggY2hhcmFjdGVyc1xuICAgIC8vIGluc3RlYWQgb2YgYSBzdHJpbmcsIHdoaWNoIHdvdWxkIGJlIGluZmluaXRlbHkgYmV0dGVyIVxuICAgIGJhc2U2NERhdGEgPSBCdWZmZXIuZnJvbShiYXNlNjREYXRhKS50b1N0cmluZygndXRmOCcpO1xuICB9XG4gIHJldHVybiB0aGlzLmlzU2ltdWxhdG9yKClcbiAgICA/IGF3YWl0IHB1c2hGaWxlVG9TaW11bGF0b3IodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgYmFzZTY0RGF0YSlcbiAgICA6IGF3YWl0IHB1c2hGaWxlVG9SZWFsRGV2aWNlKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpO1xufTtcblxuY29tbWFuZHMucHVsbEZpbGUgPSBhc3luYyBmdW5jdGlvbiBwdWxsRmlsZSAocmVtb3RlUGF0aCkge1xuICBpZiAocmVtb3RlUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEl0IGlzIGV4cGVjdGVkIHRoYXQgcmVtb3RlIHBhdGggcG9pbnRzIHRvIGEgZmlsZSBhbmQgbm90IHRvIGEgZm9sZGVyLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgJyR7cmVtb3RlUGF0aH0nIGlzIGdpdmVuIGluc3RlYWRgKTtcbiAgfVxuICByZXR1cm4gdGhpcy5pc1NpbXVsYXRvcigpXG4gICAgPyBhd2FpdCBwdWxsRnJvbVNpbXVsYXRvcih0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCB0cnVlKVxuICAgIDogYXdhaXQgcHVsbEZyb21SZWFsRGV2aWNlKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIHRydWUpO1xufTtcblxuY29tbWFuZHMubW9iaWxlRGVsZXRlRm9sZGVyID0gYXN5bmMgZnVuY3Rpb24gbW9iaWxlRGVsZXRlRm9sZGVyIChvcHRzID0ge30pIHtcbiAgbGV0IHtyZW1vdGVQYXRofSA9IG9wdHM7XG4gIGlmICghcmVtb3RlUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgcmVtb3RlUGF0aCA9IGAke3JlbW90ZVBhdGh9L2A7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGRlbGV0ZUZpbGVPckZvbGRlcih0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCB0aGlzLmlzU2ltdWxhdG9yKCkpO1xufTtcblxuY29tbWFuZHMubW9iaWxlRGVsZXRlRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIG1vYmlsZURlbGV0ZUZpbGUgKG9wdHMgPSB7fSkge1xuICBjb25zdCB7cmVtb3RlUGF0aH0gPSBvcHRzO1xuICBpZiAocmVtb3RlUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEl0IGlzIGV4cGVjdGVkIHRoYXQgcmVtb3RlIHBhdGggcG9pbnRzIHRvIGEgZmlsZSBhbmQgbm90IHRvIGEgZm9sZGVyLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgJyR7cmVtb3RlUGF0aH0nIGlzIGdpdmVuIGluc3RlYWRgKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgZGVsZXRlRmlsZU9yRm9sZGVyKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIHRoaXMuaXNTaW11bGF0b3IoKSk7XG59O1xuXG5jb21tYW5kcy5wdWxsRm9sZGVyID0gYXN5bmMgZnVuY3Rpb24gcHVsbEZvbGRlciAocmVtb3RlUGF0aCkge1xuICBpZiAoIXJlbW90ZVBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgIHJlbW90ZVBhdGggPSBgJHtyZW1vdGVQYXRofS9gO1xuICB9XG4gIHJldHVybiB0aGlzLmlzU2ltdWxhdG9yKClcbiAgICA/IGF3YWl0IHB1bGxGcm9tU2ltdWxhdG9yKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIGZhbHNlKVxuICAgIDogYXdhaXQgcHVsbEZyb21SZWFsRGV2aWNlKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIGZhbHNlKTtcbn07XG5cbmV4cG9ydCB7IGNvbW1hbmRzLCAvKiBmb3IgdGVzdGluZyAqLyBwYXJzZUNvbnRhaW5lclBhdGggfTtcbmV4cG9ydCBkZWZhdWx0IGNvbW1hbmRzO1xuIl0sImZpbGUiOiJsaWIvY29tbWFuZHMvZmlsZS1tb3ZlbWVudC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
