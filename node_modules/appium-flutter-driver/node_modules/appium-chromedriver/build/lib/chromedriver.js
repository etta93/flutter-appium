"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Chromedriver = void 0;

require("source-map-support/register");

var _events = _interopRequireDefault(require("events"));

var _baseDriver = require("@appium/base-driver");

var _child_process = _interopRequireDefault(require("child_process"));

var _support = require("@appium/support");

var _asyncbox = require("asyncbox");

var _teen_process = require("teen_process");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _utils = require("./utils");

var _semver = _interopRequireDefault(require("semver"));

var _lodash = _interopRequireDefault(require("lodash"));

var _path = _interopRequireDefault(require("path"));

var _compareVersions = _interopRequireDefault(require("compare-versions"));

var _storageClient = _interopRequireDefault(require("./storage-client"));

var _protocolHelpers = require("./protocol-helpers");

const log = _support.logger.getLogger('Chromedriver');

const NEW_CD_VERSION_FORMAT_MAJOR_VERSION = 73;
const DEFAULT_HOST = '127.0.0.1';
const MIN_CD_VERSION_WITH_W3C_SUPPORT = 75;
const DEFAULT_PORT = 9515;
const CHROME_BUNDLE_ID = 'com.android.chrome';
const WEBVIEW_SHELL_BUNDLE_ID = 'org.chromium.webview_shell';
const WEBVIEW_BUNDLE_IDS = ['com.google.android.webview', 'com.android.webview'];
const CHROMEDRIVER_TUTORIAL = 'https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/web/chromedriver.md';
const VERSION_PATTERN = /([\d.]+)/;
const CD_VERSION_TIMEOUT = 5000;

class Chromedriver extends _events.default.EventEmitter {
  constructor(args = {}) {
    super();
    const {
      host = DEFAULT_HOST,
      port = DEFAULT_PORT,
      useSystemExecutable = false,
      executable,
      executableDir = (0, _utils.getChromedriverDir)(),
      bundleId,
      mappingPath,
      cmdArgs,
      adb,
      verbose,
      logPath,
      disableBuildCheck,
      details,
      isAutodownloadEnabled = false
    } = args;
    this.proxyHost = host;
    this.proxyPort = port;
    this.adb = adb;
    this.cmdArgs = cmdArgs;
    this.proc = null;
    this.useSystemExecutable = useSystemExecutable;
    this.chromedriver = executable;
    this.executableDir = executableDir;
    this.mappingPath = mappingPath;
    this.bundleId = bundleId;
    this.executableVerified = false;
    this.state = Chromedriver.STATE_STOPPED;
    this.jwproxy = new _baseDriver.JWProxy({
      server: this.proxyHost,
      port: this.proxyPort
    });
    this.verbose = verbose;
    this.logPath = logPath;
    this.disableBuildCheck = !!disableBuildCheck;
    this.storageClient = isAutodownloadEnabled ? new _storageClient.default({
      chromedriverDir: this.executableDir
    }) : null;
    this.details = details;
    this.capabilities = {};
    this.desiredProtocol = _baseDriver.PROTOCOLS.MJSONWP;
  }

  async getDriversMapping() {
    let mapping = _lodash.default.cloneDeep(_utils.CHROMEDRIVER_CHROME_MAPPING);

    if (this.mappingPath) {
      log.debug(`Attempting to use Chromedriver->Chrome mapping from '${this.mappingPath}'`);

      if (!(await _support.fs.exists(this.mappingPath))) {
        log.warn(`No file found at '${this.mappingPath}'`);
        log.info('Defaulting to the static Chromedriver->Chrome mapping');
      } else {
        try {
          mapping = JSON.parse(await _support.fs.readFile(this.mappingPath, 'utf8'));
        } catch (err) {
          log.warn(`Error parsing mapping from '${this.mappingPath}': ${err.message}`);
          log.info('Defaulting to the static Chromedriver->Chrome mapping');
        }
      }
    } else {
      log.debug('Using the static Chromedriver->Chrome mapping');
    }

    for (const [cdVersion, chromeVersion] of _lodash.default.toPairs(mapping)) {
      const coercedVersion = _semver.default.coerce(chromeVersion);

      if (coercedVersion) {
        mapping[cdVersion] = coercedVersion.version;
      } else {
        log.info(`'${chromeVersion}' is not a valid version number. Skipping it`);
      }
    }

    return mapping;
  }

  async getChromedrivers(mapping) {
    const executables = await _support.fs.glob(`${this.executableDir}/*`);
    log.debug(`Found ${_support.util.pluralize('executable', executables.length, true)} ` + `in '${this.executableDir}'`);
    const cds = (await (0, _asyncbox.asyncmap)(executables, async function mapChromedriver(executable) {
      const logError = ({
        message,
        stdout = null,
        stderr = null
      }) => {
        let errMsg = `Cannot retrieve version number from '${_path.default.basename(executable)}' Chromedriver binary. ` + `Make sure it returns a valid version string in response to '--version' command line argument. ${message}`;

        if (stdout) {
          errMsg += `\nStdout: ${stdout}`;
        }

        if (stderr) {
          errMsg += `\nStderr: ${stderr}`;
        }

        log.warn(errMsg);
        return null;
      };

      let stdout;
      let stderr;

      try {
        ({
          stdout,
          stderr
        } = await (0, _teen_process.exec)(executable, ['--version'], {
          timeout: CD_VERSION_TIMEOUT
        }));
      } catch (err) {
        if (!(err.message || '').includes('timed out') && !(err.stdout || '').includes('Starting ChromeDriver')) {
          return logError(err);
        }

        stdout = err.stdout;
      }

      const match = /ChromeDriver\s+\(?v?([\d.]+)\)?/i.exec(stdout);

      if (!match) {
        return logError({
          message: 'Cannot parse the version string',
          stdout,
          stderr
        });
      }

      let version = match[1];
      let minChromeVersion = mapping[version];

      const coercedVersion = _semver.default.coerce(version);

      if (coercedVersion) {
        if (coercedVersion.major < NEW_CD_VERSION_FORMAT_MAJOR_VERSION) {
          version = `${coercedVersion.major}.${coercedVersion.minor}`;
          minChromeVersion = mapping[version];
        }

        if (!minChromeVersion && coercedVersion.major >= NEW_CD_VERSION_FORMAT_MAJOR_VERSION) {
          minChromeVersion = `${coercedVersion.major}`;
        }
      }

      return {
        executable,
        version,
        minChromeVersion
      };
    })).filter(cd => !!cd).sort((a, b) => (0, _compareVersions.default)(b.version, a.version));

    if (_lodash.default.isEmpty(cds)) {
      log.info(`No Chromedrivers were found in '${this.executableDir}'`);
      return cds;
    }

    log.debug(`The following Chromedriver executables were found:`);

    for (const cd of cds) {
      log.debug(`    '${cd.executable}' (version '${cd.version}', minimum Chrome version '${cd.minChromeVersion ? cd.minChromeVersion : 'Unknown'}')`);
    }

    return cds;
  }

  async getChromeVersion() {
    var _this$details, _this$details3, _this$details3$info;

    if ((_this$details = this.details) !== null && _this$details !== void 0 && _this$details.info) {
      var _this$details2, _this$details2$info;

      log.debug(`Browser version in the supplied details: ${(_this$details2 = this.details) === null || _this$details2 === void 0 ? void 0 : (_this$details2$info = _this$details2.info) === null || _this$details2$info === void 0 ? void 0 : _this$details2$info.Browser}`);
    }

    const versionMatch = VERSION_PATTERN.exec((_this$details3 = this.details) === null || _this$details3 === void 0 ? void 0 : (_this$details3$info = _this$details3.info) === null || _this$details3$info === void 0 ? void 0 : _this$details3$info.Browser);

    if (versionMatch) {
      const coercedVersion = _semver.default.coerce(versionMatch[1]);

      if (coercedVersion) {
        return coercedVersion;
      }
    }

    let chromeVersion;

    if (this.bundleId === WEBVIEW_SHELL_BUNDLE_ID) {
      for (const bundleId of WEBVIEW_BUNDLE_IDS) {
        chromeVersion = await (0, _utils.getChromeVersion)(this.adb, bundleId);

        if (chromeVersion) {
          this.bundleId = bundleId;
          return _semver.default.coerce(chromeVersion);
        }
      }

      return null;
    }

    if (this.adb) {
      const apiLevel = await this.adb.getApiLevel();

      if (apiLevel >= 24 && apiLevel <= 28 && [WEBVIEW_SHELL_BUNDLE_ID, ...WEBVIEW_BUNDLE_IDS].includes(this.bundleId)) {
        this.bundleId = CHROME_BUNDLE_ID;
      }
    }

    if (!this.bundleId) {
      this.bundleId = CHROME_BUNDLE_ID;

      for (const bundleId of WEBVIEW_BUNDLE_IDS) {
        chromeVersion = await (0, _utils.getChromeVersion)(this.adb, bundleId);

        if (chromeVersion) {
          this.bundleId = bundleId;
          break;
        }
      }
    }

    if (!chromeVersion) {
      chromeVersion = await (0, _utils.getChromeVersion)(this.adb, this.bundleId);
    }

    return chromeVersion ? _semver.default.coerce(chromeVersion) : null;
  }

  async updateDriversMapping(newMapping) {
    let shouldUpdateStaticMapping = true;

    if (await _support.fs.exists(this.mappingPath)) {
      try {
        await _support.fs.writeFile(this.mappingPath, JSON.stringify(newMapping, null, 2), 'utf8');
        shouldUpdateStaticMapping = false;
      } catch (e) {
        log.warn(`Cannot store the updated chromedrivers mapping into '${this.mappingPath}'. ` + `This may reduce the performance of further executions. Original error: ${e.message}`);
      }
    }

    if (shouldUpdateStaticMapping) {
      Object.assign(_utils.CHROMEDRIVER_CHROME_MAPPING, newMapping);
    }
  }

  async getCompatibleChromedriver() {
    if (!this.adb) {
      return await (0, _utils.getChromedriverBinaryPath)();
    }

    const mapping = await this.getDriversMapping();

    if (!_lodash.default.isEmpty(mapping)) {
      log.debug(`The most recent known Chrome version: ${_lodash.default.values(mapping)[0]}`);
    }

    let didStorageSync = false;

    const syncChromedrivers = async chromeVersion => {
      didStorageSync = true;
      const retrievedMapping = await this.storageClient.retrieveMapping();
      log.debug('Got chromedrivers mapping from the storage: ' + JSON.stringify(retrievedMapping, null, 2));
      const driverKeys = await this.storageClient.syncDrivers({
        minBrowserVersion: chromeVersion.major
      });

      if (_lodash.default.isEmpty(driverKeys)) {
        return false;
      }

      const synchronizedDriversMapping = driverKeys.reduce((acc, x) => {
        const {
          version,
          minBrowserVersion
        } = retrievedMapping[x];
        acc[version] = minBrowserVersion;
        return acc;
      }, {});
      Object.assign(mapping, synchronizedDriversMapping);
      await this.updateDriversMapping(mapping);
      return true;
    };

    do {
      const cds = await this.getChromedrivers(mapping);
      const missingVersions = {};

      for (const {
        version,
        minChromeVersion
      } of cds) {
        if (!minChromeVersion || mapping[version]) {
          continue;
        }

        const coercedVer = _semver.default.coerce(version);

        if (!coercedVer || coercedVer.major < NEW_CD_VERSION_FORMAT_MAJOR_VERSION) {
          continue;
        }

        missingVersions[version] = minChromeVersion;
      }

      if (!_lodash.default.isEmpty(missingVersions)) {
        log.info(`Found ${_support.util.pluralize('Chromedriver', _lodash.default.size(missingVersions), true)}, ` + `which ${_lodash.default.size(missingVersions) === 1 ? 'is' : 'are'} missing in the list of known versions: ` + JSON.stringify(missingVersions));
        await this.updateDriversMapping(Object.assign(mapping, missingVersions));
      }

      if (this.disableBuildCheck) {
        if (_lodash.default.isEmpty(cds)) {
          log.errorAndThrow(`There must be at least one Chromedriver executable available for use if ` + `'chromedriverDisableBuildCheck' capability is set to 'true'`);
        }

        const {
          version,
          executable
        } = cds[0];
        log.warn(`Chrome build check disabled. Using most recent Chromedriver version (${version}, at '${executable}')`);
        log.warn(`If this is wrong, set 'chromedriverDisableBuildCheck' capability to 'false'`);
        return executable;
      }

      const chromeVersion = await this.getChromeVersion();

      if (!chromeVersion) {
        if (_lodash.default.isEmpty(cds)) {
          log.errorAndThrow(`There must be at least one Chromedriver executable available for use if ` + `the current Chrome version cannot be determined`);
        }

        const {
          version,
          executable
        } = cds[0];
        log.warn(`Unable to discover Chrome version. Using Chromedriver ${version} at '${executable}'`);
        return executable;
      }

      log.debug(`Found Chrome bundle '${this.bundleId}' version '${chromeVersion}'`);
      const matchingDrivers = cds.filter(({
        minChromeVersion
      }) => {
        const minChromeVersionS = minChromeVersion && _semver.default.coerce(minChromeVersion);

        if (!minChromeVersionS) {
          return false;
        }

        return chromeVersion.major > NEW_CD_VERSION_FORMAT_MAJOR_VERSION ? minChromeVersionS.major === chromeVersion.major : _semver.default.gte(chromeVersion, minChromeVersionS);
      });

      if (_lodash.default.isEmpty(matchingDrivers)) {
        if (this.storageClient && !didStorageSync) {
          try {
            if (await syncChromedrivers(chromeVersion)) {
              continue;
            }
          } catch (e) {
            log.warn(`Cannot synchronize local chromedrivers with the remote storage at ${_utils.CD_CDN}: ` + e.message);
            log.debug(e.stack);
          }
        }

        const autodownloadSuggestion = 'You could also try to enable automated chromedrivers download server feature';
        throw new Error(`No Chromedriver found that can automate Chrome '${chromeVersion}'. ` + (!this.storageClient ? `${autodownloadSuggestion}. ` : '') + `See ${CHROMEDRIVER_TUTORIAL} for more details`);
      }

      const binPath = matchingDrivers[0].executable;
      log.debug(`Found ${_support.util.pluralize('executable', matchingDrivers.length, true)} ` + `capable of automating Chrome '${chromeVersion}'.\nChoosing the most recent, '${binPath}'.`);
      log.debug('If a specific version is required, specify it with the `chromedriverExecutable`' + 'desired capability.');
      return binPath;
    } while (true);
  }

  async initChromedriverPath() {
    if (this.executableVerified) return;

    if (!this.chromedriver) {
      this.chromedriver = this.useSystemExecutable ? await (0, _utils.getChromedriverBinaryPath)() : await this.getCompatibleChromedriver();
    }

    if (!(await _support.fs.exists(this.chromedriver))) {
      throw new Error(`Trying to use a chromedriver binary at the path ` + `${this.chromedriver}, but it doesn't exist!`);
    }

    this.executableVerified = true;
    log.info(`Set chromedriver binary as: ${this.chromedriver}`);
  }

  syncProtocol(cdVersion = null) {
    const coercedVersion = _semver.default.coerce(cdVersion);

    if (!coercedVersion || coercedVersion.major < MIN_CD_VERSION_WITH_W3C_SUPPORT) {
      log.debug(`Chromedriver v. ${cdVersion} does not fully support ${_baseDriver.PROTOCOLS.W3C} protocol. ` + `Defaulting to ${_baseDriver.PROTOCOLS.MJSONWP}`);
      return;
    }

    const chromeOptions = (0, _protocolHelpers.getCapValue)(this.capabilities, 'chromeOptions', {});

    if (chromeOptions.w3c === false) {
      log.info(`Chromedriver v. ${cdVersion} supports ${_baseDriver.PROTOCOLS.W3C} protocol, ` + `but ${_baseDriver.PROTOCOLS.MJSONWP} one has been explicitly requested`);
      return;
    }

    this.desiredProtocol = _baseDriver.PROTOCOLS.W3C;
    this.capabilities = (0, _protocolHelpers.toW3cCapNames)(this.capabilities);
  }

  async start(caps, emitStartingState = true) {
    this.capabilities = _lodash.default.cloneDeep(caps);
    this.capabilities.loggingPrefs = _lodash.default.cloneDeep((0, _protocolHelpers.getCapValue)(caps, 'loggingPrefs', {}));

    if (_lodash.default.isEmpty(this.capabilities.loggingPrefs.browser)) {
      this.capabilities.loggingPrefs.browser = 'ALL';
    }

    if (emitStartingState) {
      this.changeState(Chromedriver.STATE_STARTING);
    }

    const args = [`--port=${this.proxyPort}`];

    if (this.adb && this.adb.adbPort) {
      args.push(`--adb-port=${this.adb.adbPort}`);
    }

    if (_lodash.default.isArray(this.cmdArgs)) {
      args.push(...this.cmdArgs);
    }

    if (this.logPath) {
      args.push(`--log-path=${this.logPath}`);
    }

    if (this.disableBuildCheck) {
      args.push('--disable-build-check');
    }

    args.push('--verbose');

    const startDetector = stdout => stdout.startsWith('Starting ');

    let processIsAlive = false;
    let webviewVersion;

    try {
      await this.initChromedriverPath();
      await this.killAll();
      this.proc = new _teen_process.SubProcess(this.chromedriver, args);
      processIsAlive = true;
      this.proc.on('output', (stdout, stderr) => {
        const out = stdout + stderr;
        let match = /"Browser": "(.*)"/.exec(out);

        if (match) {
          webviewVersion = match[1];
          log.debug(`Webview version: '${webviewVersion}'`);
        }

        match = /Starting ChromeDriver ([.\d]+)/.exec(out);

        if (match) {
          log.debug(`Chromedriver version: '${match[1]}'`);
          this.syncProtocol(match[1]);
        }

        if (this.verbose) {
          for (let line of (stdout || '').trim().split('\n')) {
            if (!line.trim().length) continue;
            log.debug(`[STDOUT] ${line}`);
          }

          for (let line of (stderr || '').trim().split('\n')) {
            if (!line.trim().length) continue;
            log.error(`[STDERR] ${line}`);
          }
        }
      });
      this.proc.on('exit', (code, signal) => {
        processIsAlive = false;

        if (this.state !== Chromedriver.STATE_STOPPED && this.state !== Chromedriver.STATE_STOPPING && this.state !== Chromedriver.STATE_RESTARTING) {
          let msg = `Chromedriver exited unexpectedly with code ${code}, ` + `signal ${signal}`;
          log.error(msg);
          this.changeState(Chromedriver.STATE_STOPPED);
        }
      });
      log.info(`Spawning chromedriver with: ${this.chromedriver} ` + `${args.join(' ')}`);
      await this.proc.start(startDetector);
      await this.waitForOnline();
      await this.startSession();
    } catch (e) {
      log.debug(e);
      this.emit(Chromedriver.EVENT_ERROR, e);

      if (processIsAlive) {
        await this.proc.stop();
      }

      let message = '';

      if (e.message.includes('Chrome version must be')) {
        var _$exec;

        message += 'Unable to automate Chrome version because it is not supported by this version of Chromedriver.\n';

        if (webviewVersion) {
          message += `Chrome version on the device: ${webviewVersion}\n`;
        }

        const versionsSupportedByDriver = ((_$exec = /Chrome version must be (.+)/.exec(e.message)) === null || _$exec === void 0 ? void 0 : _$exec[1]) || '';

        if (versionsSupportedByDriver) {
          message += `Chromedriver supports Chrome version(s): ${versionsSupportedByDriver}\n`;
        }

        message += `Visit '${CHROMEDRIVER_TUTORIAL}' to troubleshoot the problem.\n`;
      }

      message += e.message;
      log.errorAndThrow(message);
    }
  }

  sessionId() {
    if (this.state !== Chromedriver.STATE_ONLINE) {
      return null;
    }

    return this.jwproxy.sessionId;
  }

  async restart() {
    log.info('Restarting chromedriver');

    if (this.state !== Chromedriver.STATE_ONLINE) {
      throw new Error("Can't restart when we're not online");
    }

    this.changeState(Chromedriver.STATE_RESTARTING);
    await this.stop(false);
    await this.start(this.capabilities, false);
  }

  async waitForOnline() {
    let chromedriverStopped = false;
    await (0, _asyncbox.retryInterval)(20, 200, async () => {
      if (this.state === Chromedriver.STATE_STOPPED) {
        chromedriverStopped = true;
        return;
      }

      await this.getStatus();
    });

    if (chromedriverStopped) {
      throw new Error('ChromeDriver crashed during startup.');
    }
  }

  async getStatus() {
    return await this.jwproxy.command('/status', 'GET');
  }

  async startSession() {
    const sessionCaps = this.desiredProtocol === _baseDriver.PROTOCOLS.W3C ? {
      capabilities: {
        alwaysMatch: this.capabilities
      }
    } : {
      desiredCapabilities: this.capabilities
    };
    log.info(`Starting ${this.desiredProtocol} Chromedriver session with capabilities: ` + JSON.stringify(sessionCaps, null, 2));
    await this.jwproxy.command('/session', 'POST', sessionCaps);
    this.changeState(Chromedriver.STATE_ONLINE);
  }

  async stop(emitStates = true) {
    if (emitStates) {
      this.changeState(Chromedriver.STATE_STOPPING);
    }

    try {
      await this.jwproxy.command('', 'DELETE');
      await this.proc.stop('SIGTERM', 20000);

      if (emitStates) {
        this.changeState(Chromedriver.STATE_STOPPED);
      }
    } catch (e) {
      log.error(e);
    }
  }

  changeState(state) {
    this.state = state;
    log.debug(`Changed state to '${state}'`);
    this.emit(Chromedriver.EVENT_CHANGED, {
      state
    });
  }

  async sendCommand(url, method, body) {
    return await this.jwproxy.command(url, method, body);
  }

  async proxyReq(req, res) {
    return await this.jwproxy.proxyReqRes(req, res);
  }

  async killAll() {
    let cmd = _support.system.isWindows() ? `wmic process where "commandline like '%chromedriver.exe%--port=${this.proxyPort}%'" delete` : `pkill -15 -f "${this.chromedriver}.*--port=${this.proxyPort}"`;
    log.debug(`Killing any old chromedrivers, running: ${cmd}`);

    try {
      await _bluebird.default.promisify(_child_process.default.exec)(cmd);
      log.debug('Successfully cleaned up old chromedrivers');
    } catch (err) {
      log.warn('No old chromedrivers seem to exist');
    }

    if (this.adb) {
      const udidIndex = this.adb.executable.defaultArgs.findIndex(item => item === '-s');
      const udid = udidIndex > -1 ? this.adb.executable.defaultArgs[udidIndex + 1] : null;

      if (udid) {
        log.debug(`Cleaning this device's adb forwarded port socket connections: ${udid}`);
      } else {
        log.debug(`Cleaning any old adb forwarded port socket connections`);
      }

      try {
        for (let conn of await this.adb.getForwardList()) {
          if (!(conn.includes('webview_devtools') && (!udid || conn.includes(udid)))) {
            continue;
          }

          let params = conn.split(/\s+/);

          if (params.length > 1) {
            await this.adb.removePortForward(params[1].replace(/[\D]*/, ''));
          }
        }
      } catch (err) {
        log.warn(`Unable to clean forwarded ports. Error: '${err.message}'. Continuing.`);
      }
    }
  }

  async hasWorkingWebview() {
    try {
      await this.jwproxy.command('/url', 'GET');
      return true;
    } catch (e) {
      return false;
    }
  }

}

exports.Chromedriver = Chromedriver;
Chromedriver.EVENT_ERROR = 'chromedriver_error';
Chromedriver.EVENT_CHANGED = 'stateChanged';
Chromedriver.STATE_STOPPED = 'stopped';
Chromedriver.STATE_STARTING = 'starting';
Chromedriver.STATE_ONLINE = 'online';
Chromedriver.STATE_STOPPING = 'stopping';
Chromedriver.STATE_RESTARTING = 'restarting';
var _default = Chromedriver;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jaHJvbWVkcml2ZXIuanMiXSwibmFtZXMiOlsibG9nIiwibG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiTkVXX0NEX1ZFUlNJT05fRk9STUFUX01BSk9SX1ZFUlNJT04iLCJERUZBVUxUX0hPU1QiLCJNSU5fQ0RfVkVSU0lPTl9XSVRIX1czQ19TVVBQT1JUIiwiREVGQVVMVF9QT1JUIiwiQ0hST01FX0JVTkRMRV9JRCIsIldFQlZJRVdfU0hFTExfQlVORExFX0lEIiwiV0VCVklFV19CVU5ETEVfSURTIiwiQ0hST01FRFJJVkVSX1RVVE9SSUFMIiwiVkVSU0lPTl9QQVRURVJOIiwiQ0RfVkVSU0lPTl9USU1FT1VUIiwiQ2hyb21lZHJpdmVyIiwiZXZlbnRzIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJhcmdzIiwiaG9zdCIsInBvcnQiLCJ1c2VTeXN0ZW1FeGVjdXRhYmxlIiwiZXhlY3V0YWJsZSIsImV4ZWN1dGFibGVEaXIiLCJidW5kbGVJZCIsIm1hcHBpbmdQYXRoIiwiY21kQXJncyIsImFkYiIsInZlcmJvc2UiLCJsb2dQYXRoIiwiZGlzYWJsZUJ1aWxkQ2hlY2siLCJkZXRhaWxzIiwiaXNBdXRvZG93bmxvYWRFbmFibGVkIiwicHJveHlIb3N0IiwicHJveHlQb3J0IiwicHJvYyIsImNocm9tZWRyaXZlciIsImV4ZWN1dGFibGVWZXJpZmllZCIsInN0YXRlIiwiU1RBVEVfU1RPUFBFRCIsImp3cHJveHkiLCJKV1Byb3h5Iiwic2VydmVyIiwic3RvcmFnZUNsaWVudCIsIkNocm9tZWRyaXZlclN0b3JhZ2VDbGllbnQiLCJjaHJvbWVkcml2ZXJEaXIiLCJjYXBhYmlsaXRpZXMiLCJkZXNpcmVkUHJvdG9jb2wiLCJQUk9UT0NPTFMiLCJNSlNPTldQIiwiZ2V0RHJpdmVyc01hcHBpbmciLCJtYXBwaW5nIiwiXyIsImNsb25lRGVlcCIsIkNIUk9NRURSSVZFUl9DSFJPTUVfTUFQUElORyIsImRlYnVnIiwiZnMiLCJleGlzdHMiLCJ3YXJuIiwiaW5mbyIsIkpTT04iLCJwYXJzZSIsInJlYWRGaWxlIiwiZXJyIiwibWVzc2FnZSIsImNkVmVyc2lvbiIsImNocm9tZVZlcnNpb24iLCJ0b1BhaXJzIiwiY29lcmNlZFZlcnNpb24iLCJzZW12ZXIiLCJjb2VyY2UiLCJ2ZXJzaW9uIiwiZ2V0Q2hyb21lZHJpdmVycyIsImV4ZWN1dGFibGVzIiwiZ2xvYiIsInV0aWwiLCJwbHVyYWxpemUiLCJsZW5ndGgiLCJjZHMiLCJtYXBDaHJvbWVkcml2ZXIiLCJsb2dFcnJvciIsInN0ZG91dCIsInN0ZGVyciIsImVyck1zZyIsInBhdGgiLCJiYXNlbmFtZSIsInRpbWVvdXQiLCJpbmNsdWRlcyIsIm1hdGNoIiwiZXhlYyIsIm1pbkNocm9tZVZlcnNpb24iLCJtYWpvciIsIm1pbm9yIiwiZmlsdGVyIiwiY2QiLCJzb3J0IiwiYSIsImIiLCJpc0VtcHR5IiwiZ2V0Q2hyb21lVmVyc2lvbiIsIkJyb3dzZXIiLCJ2ZXJzaW9uTWF0Y2giLCJhcGlMZXZlbCIsImdldEFwaUxldmVsIiwidXBkYXRlRHJpdmVyc01hcHBpbmciLCJuZXdNYXBwaW5nIiwic2hvdWxkVXBkYXRlU3RhdGljTWFwcGluZyIsIndyaXRlRmlsZSIsInN0cmluZ2lmeSIsImUiLCJPYmplY3QiLCJhc3NpZ24iLCJnZXRDb21wYXRpYmxlQ2hyb21lZHJpdmVyIiwidmFsdWVzIiwiZGlkU3RvcmFnZVN5bmMiLCJzeW5jQ2hyb21lZHJpdmVycyIsInJldHJpZXZlZE1hcHBpbmciLCJyZXRyaWV2ZU1hcHBpbmciLCJkcml2ZXJLZXlzIiwic3luY0RyaXZlcnMiLCJtaW5Ccm93c2VyVmVyc2lvbiIsInN5bmNocm9uaXplZERyaXZlcnNNYXBwaW5nIiwicmVkdWNlIiwiYWNjIiwieCIsIm1pc3NpbmdWZXJzaW9ucyIsImNvZXJjZWRWZXIiLCJzaXplIiwiZXJyb3JBbmRUaHJvdyIsIm1hdGNoaW5nRHJpdmVycyIsIm1pbkNocm9tZVZlcnNpb25TIiwiZ3RlIiwiQ0RfQ0ROIiwic3RhY2siLCJhdXRvZG93bmxvYWRTdWdnZXN0aW9uIiwiRXJyb3IiLCJiaW5QYXRoIiwiaW5pdENocm9tZWRyaXZlclBhdGgiLCJzeW5jUHJvdG9jb2wiLCJXM0MiLCJjaHJvbWVPcHRpb25zIiwidzNjIiwic3RhcnQiLCJjYXBzIiwiZW1pdFN0YXJ0aW5nU3RhdGUiLCJsb2dnaW5nUHJlZnMiLCJicm93c2VyIiwiY2hhbmdlU3RhdGUiLCJTVEFURV9TVEFSVElORyIsImFkYlBvcnQiLCJwdXNoIiwiaXNBcnJheSIsInN0YXJ0RGV0ZWN0b3IiLCJzdGFydHNXaXRoIiwicHJvY2Vzc0lzQWxpdmUiLCJ3ZWJ2aWV3VmVyc2lvbiIsImtpbGxBbGwiLCJTdWJQcm9jZXNzIiwib24iLCJvdXQiLCJsaW5lIiwidHJpbSIsInNwbGl0IiwiZXJyb3IiLCJjb2RlIiwic2lnbmFsIiwiU1RBVEVfU1RPUFBJTkciLCJTVEFURV9SRVNUQVJUSU5HIiwibXNnIiwiam9pbiIsIndhaXRGb3JPbmxpbmUiLCJzdGFydFNlc3Npb24iLCJlbWl0IiwiRVZFTlRfRVJST1IiLCJzdG9wIiwidmVyc2lvbnNTdXBwb3J0ZWRCeURyaXZlciIsInNlc3Npb25JZCIsIlNUQVRFX09OTElORSIsInJlc3RhcnQiLCJjaHJvbWVkcml2ZXJTdG9wcGVkIiwiZ2V0U3RhdHVzIiwiY29tbWFuZCIsInNlc3Npb25DYXBzIiwiYWx3YXlzTWF0Y2giLCJkZXNpcmVkQ2FwYWJpbGl0aWVzIiwiZW1pdFN0YXRlcyIsIkVWRU5UX0NIQU5HRUQiLCJzZW5kQ29tbWFuZCIsInVybCIsIm1ldGhvZCIsImJvZHkiLCJwcm94eVJlcSIsInJlcSIsInJlcyIsInByb3h5UmVxUmVzIiwiY21kIiwic3lzdGVtIiwiaXNXaW5kb3dzIiwiQiIsInByb21pc2lmeSIsImNwIiwidWRpZEluZGV4IiwiZGVmYXVsdEFyZ3MiLCJmaW5kSW5kZXgiLCJpdGVtIiwidWRpZCIsImNvbm4iLCJnZXRGb3J3YXJkTGlzdCIsInBhcmFtcyIsInJlbW92ZVBvcnRGb3J3YXJkIiwicmVwbGFjZSIsImhhc1dvcmtpbmdX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RSxPQUFWLENBQWtCLE9BQWxCLEVBQTJCLEVBQTNCLENBQTNCLENBQU47QUFDRDtBQUNGO0FBQ0YsT0FaRCxDQVlFLE9BQU9uSixHQUFQLEVBQVk7QUFDWjlELFFBQUFBLEdBQUcsQ0FBQ3lELElBQUosQ0FBVSw0Q0FBMkNLLEdBQUcsQ0FBQ0MsT0FBUSxnQkFBakU7QUFDRDtBQUNGO0FBQ0Y7O0FBRXNCLFFBQWpCbUosaUJBQWlCLEdBQUk7QUFHekIsUUFBSTtBQUNGLFlBQU0sS0FBSzNLLE9BQUwsQ0FBYTZJLE9BQWIsQ0FBcUIsTUFBckIsRUFBNkIsS0FBN0IsQ0FBTjtBQUNBLGFBQU8sSUFBUDtBQUNELEtBSEQsQ0FHRSxPQUFPeEUsQ0FBUCxFQUFVO0FBQ1YsYUFBTyxLQUFQO0FBQ0Q7QUFDRjs7QUEvbkI0Qzs7O0FBa29CL0MvRixZQUFZLENBQUMrSixXQUFiLEdBQTJCLG9CQUEzQjtBQUNBL0osWUFBWSxDQUFDNEssYUFBYixHQUE2QixjQUE3QjtBQUNBNUssWUFBWSxDQUFDeUIsYUFBYixHQUE2QixTQUE3QjtBQUNBekIsWUFBWSxDQUFDc0ksY0FBYixHQUE4QixVQUE5QjtBQUNBdEksWUFBWSxDQUFDbUssWUFBYixHQUE0QixRQUE1QjtBQUNBbkssWUFBWSxDQUFDd0osY0FBYixHQUE4QixVQUE5QjtBQUNBeEosWUFBWSxDQUFDeUosZ0JBQWIsR0FBZ0MsWUFBaEM7ZUFHZXpKLFkiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0cmFuc3BpbGU6bWFpblxuXG5pbXBvcnQgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBKV1Byb3h5LCBQUk9UT0NPTFMgfSBmcm9tICdAYXBwaXVtL2Jhc2UtZHJpdmVyJztcbmltcG9ydCBjcCBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IHN5c3RlbSwgZnMsIGxvZ2dlciwgdXRpbCB9IGZyb20gJ0BhcHBpdW0vc3VwcG9ydCc7XG5pbXBvcnQgeyByZXRyeUludGVydmFsLCBhc3luY21hcCB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCB7IFN1YlByb2Nlc3MsIGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHtcbiAgZ2V0Q2hyb21lVmVyc2lvbiwgZ2V0Q2hyb21lZHJpdmVyRGlyLCBDSFJPTUVEUklWRVJfQ0hST01FX01BUFBJTkcsXG4gIGdldENocm9tZWRyaXZlckJpbmFyeVBhdGgsIENEX0NETixcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgY29tcGFyZVZlcnNpb25zIGZyb20gJ2NvbXBhcmUtdmVyc2lvbnMnO1xuaW1wb3J0IENocm9tZWRyaXZlclN0b3JhZ2VDbGllbnQgZnJvbSAnLi9zdG9yYWdlLWNsaWVudCc7XG5pbXBvcnQgeyB0b1czY0NhcE5hbWVzLCBnZXRDYXBWYWx1ZSB9IGZyb20gJy4vcHJvdG9jb2wtaGVscGVycyc7XG5cblxuY29uc3QgbG9nID0gbG9nZ2VyLmdldExvZ2dlcignQ2hyb21lZHJpdmVyJyk7XG5cbmNvbnN0IE5FV19DRF9WRVJTSU9OX0ZPUk1BVF9NQUpPUl9WRVJTSU9OID0gNzM7XG5jb25zdCBERUZBVUxUX0hPU1QgPSAnMTI3LjAuMC4xJztcbmNvbnN0IE1JTl9DRF9WRVJTSU9OX1dJVEhfVzNDX1NVUFBPUlQgPSA3NTtcbmNvbnN0IERFRkFVTFRfUE9SVCA9IDk1MTU7XG5jb25zdCBDSFJPTUVfQlVORExFX0lEID0gJ2NvbS5hbmRyb2lkLmNocm9tZSc7XG5jb25zdCBXRUJWSUVXX1NIRUxMX0JVTkRMRV9JRCA9ICdvcmcuY2hyb21pdW0ud2Vidmlld19zaGVsbCc7XG5jb25zdCBXRUJWSUVXX0JVTkRMRV9JRFMgPSBbXG4gICdjb20uZ29vZ2xlLmFuZHJvaWQud2VidmlldycsXG4gICdjb20uYW5kcm9pZC53ZWJ2aWV3Jyxcbl07XG5jb25zdCBDSFJPTUVEUklWRVJfVFVUT1JJQUwgPSAnaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9hcHBpdW0vYmxvYi9tYXN0ZXIvZG9jcy9lbi93cml0aW5nLXJ1bm5pbmctYXBwaXVtL3dlYi9jaHJvbWVkcml2ZXIubWQnO1xuY29uc3QgVkVSU0lPTl9QQVRURVJOID0gLyhbXFxkLl0rKS87XG5cbmNvbnN0IENEX1ZFUlNJT05fVElNRU9VVCA9IDUwMDA7XG5cbmNsYXNzIENocm9tZWRyaXZlciBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoYXJncyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGhvc3QgPSBERUZBVUxUX0hPU1QsXG4gICAgICBwb3J0ID0gREVGQVVMVF9QT1JULFxuICAgICAgdXNlU3lzdGVtRXhlY3V0YWJsZSA9IGZhbHNlLFxuICAgICAgZXhlY3V0YWJsZSxcbiAgICAgIGV4ZWN1dGFibGVEaXIgPSBnZXRDaHJvbWVkcml2ZXJEaXIoKSxcbiAgICAgIGJ1bmRsZUlkLFxuICAgICAgbWFwcGluZ1BhdGgsXG4gICAgICBjbWRBcmdzLFxuICAgICAgYWRiLFxuICAgICAgdmVyYm9zZSxcbiAgICAgIGxvZ1BhdGgsXG4gICAgICBkaXNhYmxlQnVpbGRDaGVjayxcbiAgICAgIGRldGFpbHMsXG4gICAgICBpc0F1dG9kb3dubG9hZEVuYWJsZWQgPSBmYWxzZSxcbiAgICB9ID0gYXJncztcblxuICAgIHRoaXMucHJveHlIb3N0ID0gaG9zdDtcbiAgICB0aGlzLnByb3h5UG9ydCA9IHBvcnQ7XG4gICAgdGhpcy5hZGIgPSBhZGI7XG4gICAgdGhpcy5jbWRBcmdzID0gY21kQXJncztcbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgIHRoaXMudXNlU3lzdGVtRXhlY3V0YWJsZSA9IHVzZVN5c3RlbUV4ZWN1dGFibGU7XG4gICAgdGhpcy5jaHJvbWVkcml2ZXIgPSBleGVjdXRhYmxlO1xuICAgIHRoaXMuZXhlY3V0YWJsZURpciA9IGV4ZWN1dGFibGVEaXI7XG4gICAgdGhpcy5tYXBwaW5nUGF0aCA9IG1hcHBpbmdQYXRoO1xuICAgIHRoaXMuYnVuZGxlSWQgPSBidW5kbGVJZDtcbiAgICB0aGlzLmV4ZWN1dGFibGVWZXJpZmllZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUgPSBDaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBFRDtcbiAgICB0aGlzLmp3cHJveHkgPSBuZXcgSldQcm94eSh7XG4gICAgICBzZXJ2ZXI6IHRoaXMucHJveHlIb3N0LFxuICAgICAgcG9ydDogdGhpcy5wcm94eVBvcnRcbiAgICB9KTtcbiAgICB0aGlzLnZlcmJvc2UgPSB2ZXJib3NlO1xuICAgIHRoaXMubG9nUGF0aCA9IGxvZ1BhdGg7XG4gICAgdGhpcy5kaXNhYmxlQnVpbGRDaGVjayA9ICEhZGlzYWJsZUJ1aWxkQ2hlY2s7XG4gICAgdGhpcy5zdG9yYWdlQ2xpZW50ID0gaXNBdXRvZG93bmxvYWRFbmFibGVkXG4gICAgICA/IG5ldyBDaHJvbWVkcml2ZXJTdG9yYWdlQ2xpZW50KHsgY2hyb21lZHJpdmVyRGlyOiB0aGlzLmV4ZWN1dGFibGVEaXIgfSlcbiAgICAgIDogbnVsbDtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIHRoaXMuY2FwYWJpbGl0aWVzID0ge307XG4gICAgdGhpcy5kZXNpcmVkUHJvdG9jb2wgPSBQUk9UT0NPTFMuTUpTT05XUDtcbiAgfVxuXG4gIGFzeW5jIGdldERyaXZlcnNNYXBwaW5nICgpIHtcbiAgICBsZXQgbWFwcGluZyA9IF8uY2xvbmVEZWVwKENIUk9NRURSSVZFUl9DSFJPTUVfTUFQUElORyk7XG4gICAgaWYgKHRoaXMubWFwcGluZ1BhdGgpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgQXR0ZW1wdGluZyB0byB1c2UgQ2hyb21lZHJpdmVyLT5DaHJvbWUgbWFwcGluZyBmcm9tICcke3RoaXMubWFwcGluZ1BhdGh9J2ApO1xuICAgICAgaWYgKCFhd2FpdCBmcy5leGlzdHModGhpcy5tYXBwaW5nUGF0aCkpIHtcbiAgICAgICAgbG9nLndhcm4oYE5vIGZpbGUgZm91bmQgYXQgJyR7dGhpcy5tYXBwaW5nUGF0aH0nYCk7XG4gICAgICAgIGxvZy5pbmZvKCdEZWZhdWx0aW5nIHRvIHRoZSBzdGF0aWMgQ2hyb21lZHJpdmVyLT5DaHJvbWUgbWFwcGluZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtYXBwaW5nID0gSlNPTi5wYXJzZShhd2FpdCBmcy5yZWFkRmlsZSh0aGlzLm1hcHBpbmdQYXRoLCAndXRmOCcpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nLndhcm4oYEVycm9yIHBhcnNpbmcgbWFwcGluZyBmcm9tICcke3RoaXMubWFwcGluZ1BhdGh9JzogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICBsb2cuaW5mbygnRGVmYXVsdGluZyB0byB0aGUgc3RhdGljIENocm9tZWRyaXZlci0+Q2hyb21lIG1hcHBpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuZGVidWcoJ1VzaW5nIHRoZSBzdGF0aWMgQ2hyb21lZHJpdmVyLT5DaHJvbWUgbWFwcGluZycpO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZXMgZm9yIG1pbmltdW0gY2hyb21lIHZlcnNpb24gYXJlIHNlbXZlciBjb21wbGlhbnRcbiAgICBmb3IgKGNvbnN0IFtjZFZlcnNpb24sIGNocm9tZVZlcnNpb25dIG9mIF8udG9QYWlycyhtYXBwaW5nKSkge1xuICAgICAgY29uc3QgY29lcmNlZFZlcnNpb24gPSBzZW12ZXIuY29lcmNlKGNocm9tZVZlcnNpb24pO1xuICAgICAgaWYgKGNvZXJjZWRWZXJzaW9uKSB7XG4gICAgICAgIG1hcHBpbmdbY2RWZXJzaW9uXSA9IGNvZXJjZWRWZXJzaW9uLnZlcnNpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cuaW5mbyhgJyR7Y2hyb21lVmVyc2lvbn0nIGlzIG5vdCBhIHZhbGlkIHZlcnNpb24gbnVtYmVyLiBTa2lwcGluZyBpdGApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwcGluZztcbiAgfVxuXG4gIGFzeW5jIGdldENocm9tZWRyaXZlcnMgKG1hcHBpbmcpIHtcbiAgICAvLyBnbyB0aHJvdWdoIHRoZSB2ZXJzaW9ucyBhdmFpbGFibGVcbiAgICBjb25zdCBleGVjdXRhYmxlcyA9IGF3YWl0IGZzLmdsb2IoYCR7dGhpcy5leGVjdXRhYmxlRGlyfS8qYCk7XG4gICAgbG9nLmRlYnVnKGBGb3VuZCAke3V0aWwucGx1cmFsaXplKCdleGVjdXRhYmxlJywgZXhlY3V0YWJsZXMubGVuZ3RoLCB0cnVlKX0gYCArXG4gICAgICBgaW4gJyR7dGhpcy5leGVjdXRhYmxlRGlyfSdgKTtcbiAgICBjb25zdCBjZHMgPSAoYXdhaXQgYXN5bmNtYXAoZXhlY3V0YWJsZXMsIGFzeW5jIGZ1bmN0aW9uIG1hcENocm9tZWRyaXZlciAoZXhlY3V0YWJsZSkge1xuICAgICAgY29uc3QgbG9nRXJyb3IgPSAoe21lc3NhZ2UsIHN0ZG91dCA9IG51bGwsIHN0ZGVyciA9IG51bGx9KSA9PiB7XG4gICAgICAgIGxldCBlcnJNc2cgPSBgQ2Fubm90IHJldHJpZXZlIHZlcnNpb24gbnVtYmVyIGZyb20gJyR7cGF0aC5iYXNlbmFtZShleGVjdXRhYmxlKX0nIENocm9tZWRyaXZlciBiaW5hcnkuIGAgK1xuICAgICAgICAgIGBNYWtlIHN1cmUgaXQgcmV0dXJucyBhIHZhbGlkIHZlcnNpb24gc3RyaW5nIGluIHJlc3BvbnNlIHRvICctLXZlcnNpb24nIGNvbW1hbmQgbGluZSBhcmd1bWVudC4gJHttZXNzYWdlfWA7XG4gICAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgICBlcnJNc2cgKz0gYFxcblN0ZG91dDogJHtzdGRvdXR9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RkZXJyKSB7XG4gICAgICAgICAgZXJyTXNnICs9IGBcXG5TdGRlcnI6ICR7c3RkZXJyfWA7XG4gICAgICAgIH1cbiAgICAgICAgbG9nLndhcm4oZXJyTXNnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICBsZXQgc3Rkb3V0O1xuICAgICAgbGV0IHN0ZGVycjtcbiAgICAgIHRyeSB7XG4gICAgICAgICh7c3Rkb3V0LCBzdGRlcnJ9ID0gYXdhaXQgZXhlYyhleGVjdXRhYmxlLCBbJy0tdmVyc2lvbiddLCB7XG4gICAgICAgICAgdGltZW91dDogQ0RfVkVSU0lPTl9USU1FT1VULFxuICAgICAgICB9KSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCEoZXJyLm1lc3NhZ2UgfHwgJycpLmluY2x1ZGVzKCd0aW1lZCBvdXQnKSAmJiAhKGVyci5zdGRvdXQgfHwgJycpLmluY2x1ZGVzKCdTdGFydGluZyBDaHJvbWVEcml2ZXInKSkge1xuICAgICAgICAgIHJldHVybiBsb2dFcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyBoYXMgdGltZWQgb3V0LCBpdCBoYXMgYWN0dWFsbHkgc3RhcnRlZCBDaHJvbWVkcml2ZXIsXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2UgdGhlcmUgd2lsbCBhbHNvIGJlIHRoZSB2ZXJzaW9uIHN0cmluZyBpbiB0aGUgb3V0cHV0XG4gICAgICAgIHN0ZG91dCA9IGVyci5zdGRvdXQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoID0gL0Nocm9tZURyaXZlclxccytcXCg/dj8oW1xcZC5dKylcXCk/L2kuZXhlYyhzdGRvdXQpOyAvLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL3pwajV3QS8xXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBsb2dFcnJvcih7bWVzc2FnZTogJ0Nhbm5vdCBwYXJzZSB0aGUgdmVyc2lvbiBzdHJpbmcnLCBzdGRvdXQsIHN0ZGVycn0pO1xuICAgICAgfVxuICAgICAgbGV0IHZlcnNpb24gPSBtYXRjaFsxXTtcbiAgICAgIGxldCBtaW5DaHJvbWVWZXJzaW9uID0gbWFwcGluZ1t2ZXJzaW9uXTtcbiAgICAgIGNvbnN0IGNvZXJjZWRWZXJzaW9uID0gc2VtdmVyLmNvZXJjZSh2ZXJzaW9uKTtcbiAgICAgIGlmIChjb2VyY2VkVmVyc2lvbikge1xuICAgICAgICAvLyBiZWZvcmUgMjAxOS0wMy0wNiB2ZXJzaW9ucyB3ZXJlIG9mIHRoZSBmb3JtIG1ham9yLm1pbm9yXG4gICAgICAgIGlmIChjb2VyY2VkVmVyc2lvbi5tYWpvciA8IE5FV19DRF9WRVJTSU9OX0ZPUk1BVF9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgICAgdmVyc2lvbiA9IGAke2NvZXJjZWRWZXJzaW9uLm1ham9yfS4ke2NvZXJjZWRWZXJzaW9uLm1pbm9yfWA7XG4gICAgICAgICAgbWluQ2hyb21lVmVyc2lvbiA9IG1hcHBpbmdbdmVyc2lvbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtaW5DaHJvbWVWZXJzaW9uICYmIGNvZXJjZWRWZXJzaW9uLm1ham9yID49IE5FV19DRF9WRVJTSU9OX0ZPUk1BVF9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgICAgLy8gQXNzdW1lIHRoZSBtYWpvciBDaHJvbWUgdmVyc2lvbiBpcyB0aGUgc2FtZSBhcyB0aGUgY29ycmVzcG9uZGluZyBkcml2ZXIgbWFqb3IgdmVyc2lvblxuICAgICAgICAgIG1pbkNocm9tZVZlcnNpb24gPSBgJHtjb2VyY2VkVmVyc2lvbi5tYWpvcn1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleGVjdXRhYmxlLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBtaW5DaHJvbWVWZXJzaW9uLFxuICAgICAgfTtcbiAgICB9KSlcbiAgICAgIC5maWx0ZXIoKGNkKSA9PiAhIWNkKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGNvbXBhcmVWZXJzaW9ucyhiLnZlcnNpb24sIGEudmVyc2lvbikpO1xuICAgIGlmIChfLmlzRW1wdHkoY2RzKSkge1xuICAgICAgbG9nLmluZm8oYE5vIENocm9tZWRyaXZlcnMgd2VyZSBmb3VuZCBpbiAnJHt0aGlzLmV4ZWN1dGFibGVEaXJ9J2ApO1xuICAgICAgcmV0dXJuIGNkcztcbiAgICB9XG4gICAgbG9nLmRlYnVnKGBUaGUgZm9sbG93aW5nIENocm9tZWRyaXZlciBleGVjdXRhYmxlcyB3ZXJlIGZvdW5kOmApO1xuICAgIGZvciAoY29uc3QgY2Qgb2YgY2RzKSB7XG4gICAgICBsb2cuZGVidWcoYCAgICAnJHtjZC5leGVjdXRhYmxlfScgKHZlcnNpb24gJyR7Y2QudmVyc2lvbn0nLCBtaW5pbXVtIENocm9tZSB2ZXJzaW9uICcke2NkLm1pbkNocm9tZVZlcnNpb24gPyBjZC5taW5DaHJvbWVWZXJzaW9uIDogJ1Vua25vd24nfScpYCk7XG4gICAgfVxuICAgIHJldHVybiBjZHM7XG4gIH1cblxuICBhc3luYyBnZXRDaHJvbWVWZXJzaW9uICgpIHtcbiAgICAvLyBUcnkgdG8gcmV0cmlldmUgdGhlIHZlcnNpb24gZnJvbSBgZGV0YWlsc2AgcHJvcGVydHkgaWYgaXQgaXMgc2V0XG4gICAgLy8gVGhlIGBpbmZvYCBpdGVtIG11c3QgY29udGFpbiB0aGUgb3V0cHV0IG9mIC9qc29uL3ZlcnNpb24gQ0RQIGNvbW1hbmRcbiAgICAvLyB3aGVyZSBgQnJvd3NlcmAgZmllbGQgbG9va3MgbGlrZSBgQ2hyb21lLzcyLjAuMzYwMS4wYGBcbiAgICBpZiAodGhpcy5kZXRhaWxzPy5pbmZvKSB7XG4gICAgICBsb2cuZGVidWcoYEJyb3dzZXIgdmVyc2lvbiBpbiB0aGUgc3VwcGxpZWQgZGV0YWlsczogJHt0aGlzLmRldGFpbHM/LmluZm8/LkJyb3dzZXJ9YCk7XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb25NYXRjaCA9IFZFUlNJT05fUEFUVEVSTi5leGVjKHRoaXMuZGV0YWlscz8uaW5mbz8uQnJvd3Nlcik7XG4gICAgaWYgKHZlcnNpb25NYXRjaCkge1xuICAgICAgY29uc3QgY29lcmNlZFZlcnNpb24gPSBzZW12ZXIuY29lcmNlKHZlcnNpb25NYXRjaFsxXSk7XG4gICAgICBpZiAoY29lcmNlZFZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZWRWZXJzaW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBjaHJvbWVWZXJzaW9uO1xuXG4gICAgLy8gaW4gY2FzZSBvZiBXZWJWaWV3IEJyb3dzZXIgVGVzdGVyLCBzaW1wbHkgdHJ5IHRvIGZpbmQgdGhlIHVuZGVybHlpbmcgd2Vidmlld1xuICAgIGlmICh0aGlzLmJ1bmRsZUlkID09PSBXRUJWSUVXX1NIRUxMX0JVTkRMRV9JRCkge1xuICAgICAgZm9yIChjb25zdCBidW5kbGVJZCBvZiBXRUJWSUVXX0JVTkRMRV9JRFMpIHtcbiAgICAgICAgY2hyb21lVmVyc2lvbiA9IGF3YWl0IGdldENocm9tZVZlcnNpb24odGhpcy5hZGIsIGJ1bmRsZUlkKTtcbiAgICAgICAgaWYgKGNocm9tZVZlcnNpb24pIHtcbiAgICAgICAgICB0aGlzLmJ1bmRsZUlkID0gYnVuZGxlSWQ7XG4gICAgICAgICAgcmV0dXJuIHNlbXZlci5jb2VyY2UoY2hyb21lVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIG9uIEFuZHJvaWQgNy05IHdlYnZpZXdzIGFyZSBiYWNrZWQgYnkgdGhlIG1haW4gQ2hyb21lLCBub3QgdGhlIHN5c3RlbSB3ZWJ2aWV3XG4gICAgaWYgKHRoaXMuYWRiKSB7XG4gICAgICBjb25zdCBhcGlMZXZlbCA9IGF3YWl0IHRoaXMuYWRiLmdldEFwaUxldmVsKCk7XG4gICAgICBpZiAoYXBpTGV2ZWwgPj0gMjQgJiYgYXBpTGV2ZWwgPD0gMjggJiZcbiAgICAgICAgICBbV0VCVklFV19TSEVMTF9CVU5ETEVfSUQsIC4uLldFQlZJRVdfQlVORExFX0lEU10uaW5jbHVkZXModGhpcy5idW5kbGVJZCkpIHtcbiAgICAgICAgdGhpcy5idW5kbGVJZCA9IENIUk9NRV9CVU5ETEVfSUQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHJ5IG91dCB3ZWJ2aWV3cyB3aGVuIG5vIGJ1bmRsZSBpZCBpcyBzZW50IGluXG4gICAgaWYgKCF0aGlzLmJ1bmRsZUlkKSB7XG4gICAgICAvLyBkZWZhdWx0IHRvIHRoZSBnZW5lcmljIENocm9tZSBidW5kbGVcbiAgICAgIHRoaXMuYnVuZGxlSWQgPSBDSFJPTUVfQlVORExFX0lEO1xuXG4gICAgICAvLyB3ZSBoYXZlIGEgd2VidmlldyBvZiBzb21lIHNvcnQsIHNvIHRyeSB0byBmaW5kIHRoZSBidW5kbGUgdmVyc2lvblxuICAgICAgZm9yIChjb25zdCBidW5kbGVJZCBvZiBXRUJWSUVXX0JVTkRMRV9JRFMpIHtcbiAgICAgICAgY2hyb21lVmVyc2lvbiA9IGF3YWl0IGdldENocm9tZVZlcnNpb24odGhpcy5hZGIsIGJ1bmRsZUlkKTtcbiAgICAgICAgaWYgKGNocm9tZVZlcnNpb24pIHtcbiAgICAgICAgICB0aGlzLmJ1bmRsZUlkID0gYnVuZGxlSWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBkbyBub3QgaGF2ZSBhIGNocm9tZSB2ZXJzaW9uLCBpdCBtdXN0IG5vdCBiZSBhIHdlYnZpZXdcbiAgICBpZiAoIWNocm9tZVZlcnNpb24pIHtcbiAgICAgIGNocm9tZVZlcnNpb24gPSBhd2FpdCBnZXRDaHJvbWVWZXJzaW9uKHRoaXMuYWRiLCB0aGlzLmJ1bmRsZUlkKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgaXQgaXMgc2VtdmVyLCBzbyBsYXRlciBjaGVja3Mgd29uJ3QgZmFpbFxuICAgIHJldHVybiBjaHJvbWVWZXJzaW9uID8gc2VtdmVyLmNvZXJjZShjaHJvbWVWZXJzaW9uKSA6IG51bGw7XG4gIH1cblxuICBhc3luYyB1cGRhdGVEcml2ZXJzTWFwcGluZyAobmV3TWFwcGluZykge1xuICAgIGxldCBzaG91bGRVcGRhdGVTdGF0aWNNYXBwaW5nID0gdHJ1ZTtcbiAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKHRoaXMubWFwcGluZ1BhdGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmcy53cml0ZUZpbGUodGhpcy5tYXBwaW5nUGF0aCwgSlNPTi5zdHJpbmdpZnkobmV3TWFwcGluZywgbnVsbCwgMiksICd1dGY4Jyk7XG4gICAgICAgIHNob3VsZFVwZGF0ZVN0YXRpY01hcHBpbmcgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nLndhcm4oYENhbm5vdCBzdG9yZSB0aGUgdXBkYXRlZCBjaHJvbWVkcml2ZXJzIG1hcHBpbmcgaW50byAnJHt0aGlzLm1hcHBpbmdQYXRofScuIGAgK1xuICAgICAgICAgIGBUaGlzIG1heSByZWR1Y2UgdGhlIHBlcmZvcm1hbmNlIG9mIGZ1cnRoZXIgZXhlY3V0aW9ucy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkVXBkYXRlU3RhdGljTWFwcGluZykge1xuICAgICAgT2JqZWN0LmFzc2lnbihDSFJPTUVEUklWRVJfQ0hST01FX01BUFBJTkcsIG5ld01hcHBpbmcpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldENvbXBhdGlibGVDaHJvbWVkcml2ZXIgKCkge1xuICAgIGlmICghdGhpcy5hZGIpIHtcbiAgICAgIHJldHVybiBhd2FpdCBnZXRDaHJvbWVkcml2ZXJCaW5hcnlQYXRoKCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWFwcGluZyA9IGF3YWl0IHRoaXMuZ2V0RHJpdmVyc01hcHBpbmcoKTtcbiAgICBpZiAoIV8uaXNFbXB0eShtYXBwaW5nKSkge1xuICAgICAgbG9nLmRlYnVnKGBUaGUgbW9zdCByZWNlbnQga25vd24gQ2hyb21lIHZlcnNpb246ICR7Xy52YWx1ZXMobWFwcGluZylbMF19YCk7XG4gICAgfVxuXG4gICAgbGV0IGRpZFN0b3JhZ2VTeW5jID0gZmFsc2U7XG4gICAgY29uc3Qgc3luY0Nocm9tZWRyaXZlcnMgPSBhc3luYyAoY2hyb21lVmVyc2lvbikgPT4ge1xuICAgICAgZGlkU3RvcmFnZVN5bmMgPSB0cnVlO1xuICAgICAgY29uc3QgcmV0cmlldmVkTWFwcGluZyA9IGF3YWl0IHRoaXMuc3RvcmFnZUNsaWVudC5yZXRyaWV2ZU1hcHBpbmcoKTtcbiAgICAgIGxvZy5kZWJ1ZygnR290IGNocm9tZWRyaXZlcnMgbWFwcGluZyBmcm9tIHRoZSBzdG9yYWdlOiAnICtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkocmV0cmlldmVkTWFwcGluZywgbnVsbCwgMikpO1xuICAgICAgY29uc3QgZHJpdmVyS2V5cyA9IGF3YWl0IHRoaXMuc3RvcmFnZUNsaWVudC5zeW5jRHJpdmVycyh7XG4gICAgICAgIG1pbkJyb3dzZXJWZXJzaW9uOiBjaHJvbWVWZXJzaW9uLm1ham9yLFxuICAgICAgfSk7XG4gICAgICBpZiAoXy5pc0VtcHR5KGRyaXZlcktleXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN5bmNocm9uaXplZERyaXZlcnNNYXBwaW5nID0gZHJpdmVyS2V5cy5yZWR1Y2UoKGFjYywgeCkgPT4ge1xuICAgICAgICBjb25zdCB7dmVyc2lvbiwgbWluQnJvd3NlclZlcnNpb259ID0gcmV0cmlldmVkTWFwcGluZ1t4XTtcbiAgICAgICAgYWNjW3ZlcnNpb25dID0gbWluQnJvd3NlclZlcnNpb247XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgICBPYmplY3QuYXNzaWduKG1hcHBpbmcsIHN5bmNocm9uaXplZERyaXZlcnNNYXBwaW5nKTtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlRHJpdmVyc01hcHBpbmcobWFwcGluZyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgY2RzID0gYXdhaXQgdGhpcy5nZXRDaHJvbWVkcml2ZXJzKG1hcHBpbmcpO1xuXG4gICAgICBjb25zdCBtaXNzaW5nVmVyc2lvbnMgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qge3ZlcnNpb24sIG1pbkNocm9tZVZlcnNpb259IG9mIGNkcykge1xuICAgICAgICBpZiAoIW1pbkNocm9tZVZlcnNpb24gfHwgbWFwcGluZ1t2ZXJzaW9uXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZXJjZWRWZXIgPSBzZW12ZXIuY29lcmNlKHZlcnNpb24pO1xuICAgICAgICBpZiAoIWNvZXJjZWRWZXIgfHwgY29lcmNlZFZlci5tYWpvciA8IE5FV19DRF9WRVJTSU9OX0ZPUk1BVF9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBtaXNzaW5nVmVyc2lvbnNbdmVyc2lvbl0gPSBtaW5DaHJvbWVWZXJzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKCFfLmlzRW1wdHkobWlzc2luZ1ZlcnNpb25zKSkge1xuICAgICAgICBsb2cuaW5mbyhgRm91bmQgJHt1dGlsLnBsdXJhbGl6ZSgnQ2hyb21lZHJpdmVyJywgXy5zaXplKG1pc3NpbmdWZXJzaW9ucyksIHRydWUpfSwgYCArXG4gICAgICAgICAgYHdoaWNoICR7Xy5zaXplKG1pc3NpbmdWZXJzaW9ucykgPT09IDEgPyAnaXMnIDogJ2FyZSd9IG1pc3NpbmcgaW4gdGhlIGxpc3Qgb2Yga25vd24gdmVyc2lvbnM6IGAgK1xuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG1pc3NpbmdWZXJzaW9ucykpO1xuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZURyaXZlcnNNYXBwaW5nKE9iamVjdC5hc3NpZ24obWFwcGluZywgbWlzc2luZ1ZlcnNpb25zKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRpc2FibGVCdWlsZENoZWNrKSB7XG4gICAgICAgIGlmIChfLmlzRW1wdHkoY2RzKSkge1xuICAgICAgICAgIGxvZy5lcnJvckFuZFRocm93KGBUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBDaHJvbWVkcml2ZXIgZXhlY3V0YWJsZSBhdmFpbGFibGUgZm9yIHVzZSBpZiBgICtcbiAgICAgICAgICAgIGAnY2hyb21lZHJpdmVyRGlzYWJsZUJ1aWxkQ2hlY2snIGNhcGFiaWxpdHkgaXMgc2V0IHRvICd0cnVlJ2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHt2ZXJzaW9uLCBleGVjdXRhYmxlfSA9IGNkc1swXTtcbiAgICAgICAgbG9nLndhcm4oYENocm9tZSBidWlsZCBjaGVjayBkaXNhYmxlZC4gVXNpbmcgbW9zdCByZWNlbnQgQ2hyb21lZHJpdmVyIHZlcnNpb24gKCR7dmVyc2lvbn0sIGF0ICcke2V4ZWN1dGFibGV9JylgKTtcbiAgICAgICAgbG9nLndhcm4oYElmIHRoaXMgaXMgd3JvbmcsIHNldCAnY2hyb21lZHJpdmVyRGlzYWJsZUJ1aWxkQ2hlY2snIGNhcGFiaWxpdHkgdG8gJ2ZhbHNlJ2ApO1xuICAgICAgICByZXR1cm4gZXhlY3V0YWJsZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hyb21lVmVyc2lvbiA9IGF3YWl0IHRoaXMuZ2V0Q2hyb21lVmVyc2lvbigpO1xuICAgICAgaWYgKCFjaHJvbWVWZXJzaW9uKSB7XG4gICAgICAgIC8vIHVuYWJsZSB0byBnZXQgdGhlIGNocm9tZSB2ZXJzaW9uXG4gICAgICAgIGlmIChfLmlzRW1wdHkoY2RzKSkge1xuICAgICAgICAgIGxvZy5lcnJvckFuZFRocm93KGBUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBDaHJvbWVkcml2ZXIgZXhlY3V0YWJsZSBhdmFpbGFibGUgZm9yIHVzZSBpZiBgICtcbiAgICAgICAgICAgIGB0aGUgY3VycmVudCBDaHJvbWUgdmVyc2lvbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHt2ZXJzaW9uLCBleGVjdXRhYmxlfSA9IGNkc1swXTtcbiAgICAgICAgbG9nLndhcm4oYFVuYWJsZSB0byBkaXNjb3ZlciBDaHJvbWUgdmVyc2lvbi4gVXNpbmcgQ2hyb21lZHJpdmVyICR7dmVyc2lvbn0gYXQgJyR7ZXhlY3V0YWJsZX0nYCk7XG4gICAgICAgIHJldHVybiBleGVjdXRhYmxlO1xuICAgICAgfVxuICAgICAgbG9nLmRlYnVnKGBGb3VuZCBDaHJvbWUgYnVuZGxlICcke3RoaXMuYnVuZGxlSWR9JyB2ZXJzaW9uICcke2Nocm9tZVZlcnNpb259J2ApO1xuXG4gICAgICBjb25zdCBtYXRjaGluZ0RyaXZlcnMgPSBjZHMuZmlsdGVyKCh7bWluQ2hyb21lVmVyc2lvbn0pID0+IHtcbiAgICAgICAgY29uc3QgbWluQ2hyb21lVmVyc2lvblMgPSBtaW5DaHJvbWVWZXJzaW9uICYmIHNlbXZlci5jb2VyY2UobWluQ2hyb21lVmVyc2lvbik7XG4gICAgICAgIGlmICghbWluQ2hyb21lVmVyc2lvblMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hyb21lVmVyc2lvbi5tYWpvciA+IE5FV19DRF9WRVJTSU9OX0ZPUk1BVF9NQUpPUl9WRVJTSU9OXG4gICAgICAgICAgPyBtaW5DaHJvbWVWZXJzaW9uUy5tYWpvciA9PT0gY2hyb21lVmVyc2lvbi5tYWpvclxuICAgICAgICAgIDogc2VtdmVyLmd0ZShjaHJvbWVWZXJzaW9uLCBtaW5DaHJvbWVWZXJzaW9uUyk7XG4gICAgICB9KTtcbiAgICAgIGlmIChfLmlzRW1wdHkobWF0Y2hpbmdEcml2ZXJzKSkge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlQ2xpZW50ICYmICFkaWRTdG9yYWdlU3luYykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgc3luY0Nocm9tZWRyaXZlcnMoY2hyb21lVmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nLndhcm4oYENhbm5vdCBzeW5jaHJvbml6ZSBsb2NhbCBjaHJvbWVkcml2ZXJzIHdpdGggdGhlIHJlbW90ZSBzdG9yYWdlIGF0ICR7Q0RfQ0ROfTogYCArXG4gICAgICAgICAgICAgIGUubWVzc2FnZSk7XG4gICAgICAgICAgICBsb2cuZGVidWcoZS5zdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1dG9kb3dubG9hZFN1Z2dlc3Rpb24gPVxuICAgICAgICAgICdZb3UgY291bGQgYWxzbyB0cnkgdG8gZW5hYmxlIGF1dG9tYXRlZCBjaHJvbWVkcml2ZXJzIGRvd25sb2FkIHNlcnZlciBmZWF0dXJlJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBDaHJvbWVkcml2ZXIgZm91bmQgdGhhdCBjYW4gYXV0b21hdGUgQ2hyb21lICcke2Nocm9tZVZlcnNpb259Jy4gYCArXG4gICAgICAgICAgKCF0aGlzLnN0b3JhZ2VDbGllbnQgPyBgJHthdXRvZG93bmxvYWRTdWdnZXN0aW9ufS4gYCA6ICcnKSArXG4gICAgICAgICAgYFNlZSAke0NIUk9NRURSSVZFUl9UVVRPUklBTH0gZm9yIG1vcmUgZGV0YWlsc2ApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiaW5QYXRoID0gbWF0Y2hpbmdEcml2ZXJzWzBdLmV4ZWN1dGFibGU7XG4gICAgICBsb2cuZGVidWcoYEZvdW5kICR7dXRpbC5wbHVyYWxpemUoJ2V4ZWN1dGFibGUnLCBtYXRjaGluZ0RyaXZlcnMubGVuZ3RoLCB0cnVlKX0gYCArXG4gICAgICAgIGBjYXBhYmxlIG9mIGF1dG9tYXRpbmcgQ2hyb21lICcke2Nocm9tZVZlcnNpb259Jy5cXG5DaG9vc2luZyB0aGUgbW9zdCByZWNlbnQsICcke2JpblBhdGh9Jy5gKTtcbiAgICAgIGxvZy5kZWJ1ZygnSWYgYSBzcGVjaWZpYyB2ZXJzaW9uIGlzIHJlcXVpcmVkLCBzcGVjaWZ5IGl0IHdpdGggdGhlIGBjaHJvbWVkcml2ZXJFeGVjdXRhYmxlYCcgK1xuICAgICAgICAnZGVzaXJlZCBjYXBhYmlsaXR5LicpO1xuICAgICAgcmV0dXJuIGJpblBhdGg7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIH0gd2hpbGUgKHRydWUpO1xuICB9XG5cbiAgYXN5bmMgaW5pdENocm9tZWRyaXZlclBhdGggKCkge1xuICAgIGlmICh0aGlzLmV4ZWN1dGFibGVWZXJpZmllZCkgcmV0dXJuOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcblxuICAgIC8vIHRoZSBleGVjdXRhYmxlIG1pZ2h0IGJlIHNldCAoaWYgcGFzc2VkIGluKVxuICAgIC8vIG9yIHdlIG1pZ2h0IHdhbnQgdG8gdXNlIHRoZSBiYXNpYyBvbmUgaW5zdGFsbGVkIHdpdGggdGhpcyBkcml2ZXJcbiAgICAvLyBvciB3ZSB3YW50IHRvIGZpZ3VyZSBvdXQgdGhlIGJlc3Qgb25lXG4gICAgaWYgKCF0aGlzLmNocm9tZWRyaXZlcikge1xuICAgICAgdGhpcy5jaHJvbWVkcml2ZXIgPSB0aGlzLnVzZVN5c3RlbUV4ZWN1dGFibGVcbiAgICAgICAgPyBhd2FpdCBnZXRDaHJvbWVkcml2ZXJCaW5hcnlQYXRoKClcbiAgICAgICAgOiBhd2FpdCB0aGlzLmdldENvbXBhdGlibGVDaHJvbWVkcml2ZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyh0aGlzLmNocm9tZWRyaXZlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJ5aW5nIHRvIHVzZSBhIGNocm9tZWRyaXZlciBiaW5hcnkgYXQgdGhlIHBhdGggYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5jaHJvbWVkcml2ZXJ9LCBidXQgaXQgZG9lc24ndCBleGlzdCFgKTtcbiAgICB9XG4gICAgdGhpcy5leGVjdXRhYmxlVmVyaWZpZWQgPSB0cnVlO1xuICAgIGxvZy5pbmZvKGBTZXQgY2hyb21lZHJpdmVyIGJpbmFyeSBhczogJHt0aGlzLmNocm9tZWRyaXZlcn1gKTtcbiAgfVxuXG4gIHN5bmNQcm90b2NvbCAoY2RWZXJzaW9uID0gbnVsbCkge1xuICAgIGNvbnN0IGNvZXJjZWRWZXJzaW9uID0gc2VtdmVyLmNvZXJjZShjZFZlcnNpb24pO1xuICAgIGlmICghY29lcmNlZFZlcnNpb24gfHwgY29lcmNlZFZlcnNpb24ubWFqb3IgPCBNSU5fQ0RfVkVSU0lPTl9XSVRIX1czQ19TVVBQT1JUKSB7XG4gICAgICBsb2cuZGVidWcoYENocm9tZWRyaXZlciB2LiAke2NkVmVyc2lvbn0gZG9lcyBub3QgZnVsbHkgc3VwcG9ydCAke1BST1RPQ09MUy5XM0N9IHByb3RvY29sLiBgICtcbiAgICAgICAgYERlZmF1bHRpbmcgdG8gJHtQUk9UT0NPTFMuTUpTT05XUH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hyb21lT3B0aW9ucyA9IGdldENhcFZhbHVlKHRoaXMuY2FwYWJpbGl0aWVzLCAnY2hyb21lT3B0aW9ucycsIHt9KTtcbiAgICBpZiAoY2hyb21lT3B0aW9ucy53M2MgPT09IGZhbHNlKSB7XG4gICAgICBsb2cuaW5mbyhgQ2hyb21lZHJpdmVyIHYuICR7Y2RWZXJzaW9ufSBzdXBwb3J0cyAke1BST1RPQ09MUy5XM0N9IHByb3RvY29sLCBgICtcbiAgICAgICAgYGJ1dCAke1BST1RPQ09MUy5NSlNPTldQfSBvbmUgaGFzIGJlZW4gZXhwbGljaXRseSByZXF1ZXN0ZWRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZXNpcmVkUHJvdG9jb2wgPSBQUk9UT0NPTFMuVzNDO1xuICAgIC8vIGdpdmVuIGNhcHMgbWlnaHQgbm90IGJlIHByb3Blcmx5IHByZWZpeGVkXG4gICAgLy8gc28gd2UgdHJ5IHRvIGZpeCB0aGVtIGluIG9yZGVyIHRvIHByb3Blcmx5IGluaXRcbiAgICAvLyB0aGUgbmV3IFczQyBzZXNzaW9uXG4gICAgdGhpcy5jYXBhYmlsaXRpZXMgPSB0b1czY0NhcE5hbWVzKHRoaXMuY2FwYWJpbGl0aWVzKTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0IChjYXBzLCBlbWl0U3RhcnRpbmdTdGF0ZSA9IHRydWUpIHtcbiAgICB0aGlzLmNhcGFiaWxpdGllcyA9IF8uY2xvbmVEZWVwKGNhcHMpO1xuXG4gICAgLy8gc2V0IHRoZSBsb2dnaW5nIHByZWZlcmVuY2VzIHRvIEFMTCB0aGUgY29uc29sZSBsb2dzXG4gICAgdGhpcy5jYXBhYmlsaXRpZXMubG9nZ2luZ1ByZWZzID0gXy5jbG9uZURlZXAoZ2V0Q2FwVmFsdWUoY2FwcywgJ2xvZ2dpbmdQcmVmcycsIHt9KSk7XG4gICAgaWYgKF8uaXNFbXB0eSh0aGlzLmNhcGFiaWxpdGllcy5sb2dnaW5nUHJlZnMuYnJvd3NlcikpIHtcbiAgICAgIHRoaXMuY2FwYWJpbGl0aWVzLmxvZ2dpbmdQcmVmcy5icm93c2VyID0gJ0FMTCc7XG4gICAgfVxuXG4gICAgaWYgKGVtaXRTdGFydGluZ1N0YXRlKSB7XG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKENocm9tZWRyaXZlci5TVEFURV9TVEFSVElORyk7XG4gICAgfVxuXG4gICAgY29uc3QgYXJncyA9IFtgLS1wb3J0PSR7dGhpcy5wcm94eVBvcnR9YF07XG4gICAgaWYgKHRoaXMuYWRiICYmIHRoaXMuYWRiLmFkYlBvcnQpIHtcbiAgICAgIGFyZ3MucHVzaChgLS1hZGItcG9ydD0ke3RoaXMuYWRiLmFkYlBvcnR9YCk7XG4gICAgfVxuICAgIGlmIChfLmlzQXJyYXkodGhpcy5jbWRBcmdzKSkge1xuICAgICAgYXJncy5wdXNoKC4uLnRoaXMuY21kQXJncyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxvZ1BhdGgpIHtcbiAgICAgIGFyZ3MucHVzaChgLS1sb2ctcGF0aD0ke3RoaXMubG9nUGF0aH1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGlzYWJsZUJ1aWxkQ2hlY2spIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1kaXNhYmxlLWJ1aWxkLWNoZWNrJyk7XG4gICAgfVxuICAgIGFyZ3MucHVzaCgnLS12ZXJib3NlJyk7XG4gICAgLy8gd2hhdCBhcmUgdGhlIHByb2Nlc3Mgc3Rkb3V0L3N0ZGVyciBjb25kaXRpb25zIHdoZXJlaW4gd2Uga25vdyB0aGF0XG4gICAgLy8gdGhlIHByb2Nlc3MgaGFzIHN0YXJ0ZWQgdG8gb3VyIHNhdGlzZmFjdGlvbj9cbiAgICBjb25zdCBzdGFydERldGVjdG9yID0gKHN0ZG91dCkgPT4gc3Rkb3V0LnN0YXJ0c1dpdGgoJ1N0YXJ0aW5nICcpO1xuXG4gICAgbGV0IHByb2Nlc3NJc0FsaXZlID0gZmFsc2U7XG4gICAgbGV0IHdlYnZpZXdWZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRDaHJvbWVkcml2ZXJQYXRoKCk7XG4gICAgICBhd2FpdCB0aGlzLmtpbGxBbGwoKTtcblxuICAgICAgLy8gc2V0IHVwIG91ciBzdWJwcm9jZXNzIG9iamVjdFxuICAgICAgdGhpcy5wcm9jID0gbmV3IFN1YlByb2Nlc3ModGhpcy5jaHJvbWVkcml2ZXIsIGFyZ3MpO1xuICAgICAgcHJvY2Vzc0lzQWxpdmUgPSB0cnVlO1xuXG4gICAgICAvLyBoYW5kbGUgbG9nIG91dHB1dFxuICAgICAgdGhpcy5wcm9jLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgLy8gaWYgdGhlIGNkIG91dHB1dCBpcyBub3QgcHJpbnRlZCwgZmluZCB0aGUgY2hyb21lIHZlcnNpb24gYW5kIHByaW50XG4gICAgICAgIC8vIHdpbGwgZ2V0IGEgcmVzcG9uc2UgbGlrZVxuICAgICAgICAvLyAgIERldlRvb2xzIHJlc3BvbnNlOiB7XG4gICAgICAgIC8vICAgICAgXCJBbmRyb2lkLVBhY2thZ2VcIjogXCJpby5hcHBpdW0uc2FtcGxlYXBwXCIsXG4gICAgICAgIC8vICAgICAgXCJCcm93c2VyXCI6IFwiQ2hyb21lLzU1LjAuMjg4My45MVwiLFxuICAgICAgICAvLyAgICAgIFwiUHJvdG9jb2wtVmVyc2lvblwiOiBcIjEuMlwiLFxuICAgICAgICAvLyAgICAgIFwiVXNlci1BZ2VudFwiOiBcIi4uLlwiLFxuICAgICAgICAvLyAgICAgIFwiV2ViS2l0LVZlcnNpb25cIjogXCI1MzcuMzZcIlxuICAgICAgICAvLyAgIH1cbiAgICAgICAgY29uc3Qgb3V0ID0gc3Rkb3V0ICsgc3RkZXJyO1xuICAgICAgICBsZXQgbWF0Y2ggPSAvXCJCcm93c2VyXCI6IFwiKC4qKVwiLy5leGVjKG91dCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHdlYnZpZXdWZXJzaW9uID0gbWF0Y2hbMV07XG4gICAgICAgICAgbG9nLmRlYnVnKGBXZWJ2aWV3IHZlcnNpb246ICcke3dlYnZpZXdWZXJzaW9ufSdgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFsc28gcHJpbnQgY2hyb21lZHJpdmVyIHZlcnNpb24gdG8gbG9nc1xuICAgICAgICAvLyB3aWxsIG91dHB1dCBzb21ldGhpbmcgbGlrZVxuICAgICAgICAvLyAgU3RhcnRpbmcgQ2hyb21lRHJpdmVyIDIuMzMuNTA2MTA2ICg4YTA2YzM5YzQ1ODJmYmZiYWI2OTY2ZGJiMWMzOGE5MTczYmZiMWEyKSBvbiBwb3J0IDk1MTVcbiAgICAgICAgbWF0Y2ggPSAvU3RhcnRpbmcgQ2hyb21lRHJpdmVyIChbLlxcZF0rKS8uZXhlYyhvdXQpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBsb2cuZGVidWcoYENocm9tZWRyaXZlciB2ZXJzaW9uOiAnJHttYXRjaFsxXX0nYCk7XG4gICAgICAgICAgdGhpcy5zeW5jUHJvdG9jb2wobWF0Y2hbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2l2ZSB0aGUgb3V0cHV0IGlmIGl0IGlzIHJlcXVlc3RlZFxuICAgICAgICBpZiAodGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGluZSBvZiAoc3Rkb3V0IHx8ICcnKS50cmltKCkuc3BsaXQoJ1xcbicpKSB7XG4gICAgICAgICAgICBpZiAoIWxpbmUudHJpbSgpLmxlbmd0aCkgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhgW1NURE9VVF0gJHtsaW5lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBsaW5lIG9mIChzdGRlcnIgfHwgJycpLnRyaW0oKS5zcGxpdCgnXFxuJykpIHtcbiAgICAgICAgICAgIGlmICghbGluZS50cmltKCkubGVuZ3RoKSBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjdXJseVxuICAgICAgICAgICAgbG9nLmVycm9yKGBbU1RERVJSXSAke2xpbmV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gaGFuZGxlIG91dC1vZi1ib3VuZCBleGl0IGJ5IHNpbXBseSBlbWl0dGluZyBhIHN0b3BwZWQgc3RhdGVcbiAgICAgIHRoaXMucHJvYy5vbignZXhpdCcsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICAgICAgcHJvY2Vzc0lzQWxpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IENocm9tZWRyaXZlci5TVEFURV9TVE9QUEVEICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlICE9PSBDaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBJTkcgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IENocm9tZWRyaXZlci5TVEFURV9SRVNUQVJUSU5HKSB7XG4gICAgICAgICAgbGV0IG1zZyA9IGBDaHJvbWVkcml2ZXIgZXhpdGVkIHVuZXhwZWN0ZWRseSB3aXRoIGNvZGUgJHtjb2RlfSwgYCArXG4gICAgICAgICAgICAgICAgICAgIGBzaWduYWwgJHtzaWduYWx9YDtcbiAgICAgICAgICBsb2cuZXJyb3IobXNnKTtcbiAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKENocm9tZWRyaXZlci5TVEFURV9TVE9QUEVEKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsb2cuaW5mbyhgU3Bhd25pbmcgY2hyb21lZHJpdmVyIHdpdGg6ICR7dGhpcy5jaHJvbWVkcml2ZXJ9IGAgK1xuICAgICAgICAgICAgICAgYCR7YXJncy5qb2luKCcgJyl9YCk7XG4gICAgICAvLyBzdGFydCBzdWJwcm9jIGFuZCB3YWl0IGZvciBzdGFydERldGVjdG9yXG4gICAgICBhd2FpdCB0aGlzLnByb2Muc3RhcnQoc3RhcnREZXRlY3Rvcik7XG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JPbmxpbmUoKTtcbiAgICAgIGF3YWl0IHRoaXMuc3RhcnRTZXNzaW9uKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmRlYnVnKGUpO1xuICAgICAgdGhpcy5lbWl0KENocm9tZWRyaXZlci5FVkVOVF9FUlJPUiwgZSk7XG4gICAgICAvLyBqdXN0IGJlY2F1c2Ugd2UgaGFkIGFuIGVycm9yIGRvZXNuJ3QgbWVhbiB0aGUgY2hyb21lZHJpdmVyIHByb2Nlc3NcbiAgICAgIC8vIGZpbmlzaGVkOyB3ZSBzaG91bGQgY2xlYW4gdXAgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAocHJvY2Vzc0lzQWxpdmUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICAgIC8vIG9mdGVuIHRoZSB1c2VyJ3MgQ2hyb21lIHZlcnNpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgdmVyc2lvbiBvZiBDaHJvbWVkcml2ZXJcbiAgICAgIGlmIChlLm1lc3NhZ2UuaW5jbHVkZXMoJ0Nocm9tZSB2ZXJzaW9uIG11c3QgYmUnKSkge1xuICAgICAgICBtZXNzYWdlICs9ICdVbmFibGUgdG8gYXV0b21hdGUgQ2hyb21lIHZlcnNpb24gYmVjYXVzZSBpdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgdmVyc2lvbiBvZiBDaHJvbWVkcml2ZXIuXFxuJztcbiAgICAgICAgaWYgKHdlYnZpZXdWZXJzaW9uKSB7XG4gICAgICAgICAgbWVzc2FnZSArPSBgQ2hyb21lIHZlcnNpb24gb24gdGhlIGRldmljZTogJHt3ZWJ2aWV3VmVyc2lvbn1cXG5gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlcnNpb25zU3VwcG9ydGVkQnlEcml2ZXIgPSAvQ2hyb21lIHZlcnNpb24gbXVzdCBiZSAoLispLy5leGVjKGUubWVzc2FnZSk/LlsxXSB8fCAnJztcbiAgICAgICAgaWYgKHZlcnNpb25zU3VwcG9ydGVkQnlEcml2ZXIpIHtcbiAgICAgICAgICBtZXNzYWdlICs9IGBDaHJvbWVkcml2ZXIgc3VwcG9ydHMgQ2hyb21lIHZlcnNpb24ocyk6ICR7dmVyc2lvbnNTdXBwb3J0ZWRCeURyaXZlcn1cXG5gO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UgKz0gYFZpc2l0ICcke0NIUk9NRURSSVZFUl9UVVRPUklBTH0nIHRvIHRyb3VibGVzaG9vdCB0aGUgcHJvYmxlbS5cXG5gO1xuICAgICAgfVxuXG4gICAgICBtZXNzYWdlICs9IGUubWVzc2FnZTtcbiAgICAgIGxvZy5lcnJvckFuZFRocm93KG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHNlc3Npb25JZCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IENocm9tZWRyaXZlci5TVEFURV9PTkxJTkUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmp3cHJveHkuc2Vzc2lvbklkO1xuICB9XG5cbiAgYXN5bmMgcmVzdGFydCAoKSB7XG4gICAgbG9nLmluZm8oJ1Jlc3RhcnRpbmcgY2hyb21lZHJpdmVyJyk7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IENocm9tZWRyaXZlci5TVEFURV9PTkxJTkUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHJlc3RhcnQgd2hlbiB3ZSdyZSBub3Qgb25saW5lXCIpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZVN0YXRlKENocm9tZWRyaXZlci5TVEFURV9SRVNUQVJUSU5HKTtcbiAgICBhd2FpdCB0aGlzLnN0b3AoZmFsc2UpO1xuICAgIGF3YWl0IHRoaXMuc3RhcnQodGhpcy5jYXBhYmlsaXRpZXMsIGZhbHNlKTtcbiAgfVxuXG4gIGFzeW5jIHdhaXRGb3JPbmxpbmUgKCkge1xuICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgQ0QgaGFzbid0IGNyYXNoZWRcbiAgICBsZXQgY2hyb21lZHJpdmVyU3RvcHBlZCA9IGZhbHNlO1xuICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoMjAsIDIwMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENocm9tZWRyaXZlci5TVEFURV9TVE9QUEVEKSB7XG4gICAgICAgIC8vIHdlIGFyZSBlaXRoZXIgc3RvcHBlZCBvciBzdG9wcGluZywgc28gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgICAgY2hyb21lZHJpdmVyU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuZ2V0U3RhdHVzKCk7XG4gICAgfSk7XG4gICAgaWYgKGNocm9tZWRyaXZlclN0b3BwZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2hyb21lRHJpdmVyIGNyYXNoZWQgZHVyaW5nIHN0YXJ0dXAuJyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0U3RhdHVzICgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5qd3Byb3h5LmNvbW1hbmQoJy9zdGF0dXMnLCAnR0VUJyk7XG4gIH1cblxuICBhc3luYyBzdGFydFNlc3Npb24gKCkge1xuICAgIGNvbnN0IHNlc3Npb25DYXBzID0gdGhpcy5kZXNpcmVkUHJvdG9jb2wgPT09IFBST1RPQ09MUy5XM0NcbiAgICAgID8ge2NhcGFiaWxpdGllczoge2Fsd2F5c01hdGNoOiB0aGlzLmNhcGFiaWxpdGllc319XG4gICAgICA6IHtkZXNpcmVkQ2FwYWJpbGl0aWVzOiB0aGlzLmNhcGFiaWxpdGllc307XG4gICAgbG9nLmluZm8oYFN0YXJ0aW5nICR7dGhpcy5kZXNpcmVkUHJvdG9jb2x9IENocm9tZWRyaXZlciBzZXNzaW9uIHdpdGggY2FwYWJpbGl0aWVzOiBgICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHNlc3Npb25DYXBzLCBudWxsLCAyKSk7XG4gICAgYXdhaXQgdGhpcy5qd3Byb3h5LmNvbW1hbmQoJy9zZXNzaW9uJywgJ1BPU1QnLCBzZXNzaW9uQ2Fwcyk7XG4gICAgdGhpcy5jaGFuZ2VTdGF0ZShDaHJvbWVkcml2ZXIuU1RBVEVfT05MSU5FKTtcbiAgfVxuXG4gIGFzeW5jIHN0b3AgKGVtaXRTdGF0ZXMgPSB0cnVlKSB7XG4gICAgaWYgKGVtaXRTdGF0ZXMpIHtcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQSU5HKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKCcnLCAnREVMRVRFJyk7XG4gICAgICBhd2FpdCB0aGlzLnByb2Muc3RvcCgnU0lHVEVSTScsIDIwMDAwKTtcbiAgICAgIGlmIChlbWl0U3RhdGVzKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZy5lcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VTdGF0ZSAoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgbG9nLmRlYnVnKGBDaGFuZ2VkIHN0YXRlIHRvICcke3N0YXRlfSdgKTtcbiAgICB0aGlzLmVtaXQoQ2hyb21lZHJpdmVyLkVWRU5UX0NIQU5HRUQsIHtzdGF0ZX0pO1xuICB9XG5cbiAgYXN5bmMgc2VuZENvbW1hbmQgKHVybCwgbWV0aG9kLCBib2R5KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKHVybCwgbWV0aG9kLCBib2R5KTtcbiAgfVxuXG4gIGFzeW5jIHByb3h5UmVxIChyZXEsIHJlcykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmp3cHJveHkucHJveHlSZXFSZXMocmVxLCByZXMpO1xuICB9XG5cbiAgYXN5bmMga2lsbEFsbCAoKSB7XG4gICAgbGV0IGNtZCA9IHN5c3RlbS5pc1dpbmRvd3MoKVxuICAgICAgPyBgd21pYyBwcm9jZXNzIHdoZXJlIFwiY29tbWFuZGxpbmUgbGlrZSAnJWNocm9tZWRyaXZlci5leGUlLS1wb3J0PSR7dGhpcy5wcm94eVBvcnR9JSdcIiBkZWxldGVgXG4gICAgICA6IGBwa2lsbCAtMTUgLWYgXCIke3RoaXMuY2hyb21lZHJpdmVyfS4qLS1wb3J0PSR7dGhpcy5wcm94eVBvcnR9XCJgO1xuICAgIGxvZy5kZWJ1ZyhgS2lsbGluZyBhbnkgb2xkIGNocm9tZWRyaXZlcnMsIHJ1bm5pbmc6ICR7Y21kfWApO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCAoQi5wcm9taXNpZnkoY3AuZXhlYykpKGNtZCk7XG4gICAgICBsb2cuZGVidWcoJ1N1Y2Nlc3NmdWxseSBjbGVhbmVkIHVwIG9sZCBjaHJvbWVkcml2ZXJzJyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybignTm8gb2xkIGNocm9tZWRyaXZlcnMgc2VlbSB0byBleGlzdCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFkYikge1xuICAgICAgY29uc3QgdWRpZEluZGV4ID0gdGhpcy5hZGIuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0gPT09ICctcycpO1xuICAgICAgY29uc3QgdWRpZCA9IHVkaWRJbmRleCA+IC0xID8gdGhpcy5hZGIuZXhlY3V0YWJsZS5kZWZhdWx0QXJnc1t1ZGlkSW5kZXggKyAxXSA6IG51bGw7XG5cbiAgICAgIGlmICh1ZGlkKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgQ2xlYW5pbmcgdGhpcyBkZXZpY2UncyBhZGIgZm9yd2FyZGVkIHBvcnQgc29ja2V0IGNvbm5lY3Rpb25zOiAke3VkaWR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cuZGVidWcoYENsZWFuaW5nIGFueSBvbGQgYWRiIGZvcndhcmRlZCBwb3J0IHNvY2tldCBjb25uZWN0aW9uc2ApO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGxldCBjb25uIG9mIGF3YWl0IHRoaXMuYWRiLmdldEZvcndhcmRMaXN0KCkpIHtcbiAgICAgICAgICAvLyBjaHJvbWVkcml2ZXIgd2lsbCBhc2sgQURCIHRvIGZvcndhcmQgYSBwb3J0IGxpa2UgXCJkZXZpY2VJZCB0Y3A6cG9ydCBsb2NhbGFic3RyYWN0OndlYnZpZXdfZGV2dG9vbHNfcmVtb3RlX3BvcnRcIlxuICAgICAgICAgIGlmICghKGNvbm4uaW5jbHVkZXMoJ3dlYnZpZXdfZGV2dG9vbHMnKSAmJiAoIXVkaWQgfHwgY29ubi5pbmNsdWRlcyh1ZGlkKSkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcGFyYW1zID0gY29ubi5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGIucmVtb3ZlUG9ydEZvcndhcmQocGFyYW1zWzFdLnJlcGxhY2UoL1tcXERdKi8sICcnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLndhcm4oYFVuYWJsZSB0byBjbGVhbiBmb3J3YXJkZWQgcG9ydHMuIEVycm9yOiAnJHtlcnIubWVzc2FnZX0nLiBDb250aW51aW5nLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhc1dvcmtpbmdXZWJ2aWV3ICgpIHtcbiAgICAvLyBzb21ldGltZXMgY2hyb21lZHJpdmVyIHN0b3BzIGF1dG9tYXRpbmcgd2Vidmlld3MuIHRoaXMgbWV0aG9kIHJ1bnMgYVxuICAgIC8vIHNpbXBsZSBjb21tYW5kIHRvIGRldGVybWluZSBvdXIgc3RhdGUsIGFuZCByZXNwb25kcyBhY2NvcmRpbmdseVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnL3VybCcsICdHRVQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuQ2hyb21lZHJpdmVyLkVWRU5UX0VSUk9SID0gJ2Nocm9tZWRyaXZlcl9lcnJvcic7XG5DaHJvbWVkcml2ZXIuRVZFTlRfQ0hBTkdFRCA9ICdzdGF0ZUNoYW5nZWQnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQgPSAnc3RvcHBlZCc7XG5DaHJvbWVkcml2ZXIuU1RBVEVfU1RBUlRJTkcgPSAnc3RhcnRpbmcnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX09OTElORSA9ICdvbmxpbmUnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQSU5HID0gJ3N0b3BwaW5nJztcbkNocm9tZWRyaXZlci5TVEFURV9SRVNUQVJUSU5HID0gJ3Jlc3RhcnRpbmcnO1xuXG5leHBvcnQgeyBDaHJvbWVkcml2ZXIgfTtcbmV4cG9ydCBkZWZhdWx0IENocm9tZWRyaXZlcjtcbiJdLCJmaWxlIjoibGliL2Nocm9tZWRyaXZlci5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
