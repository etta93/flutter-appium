"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _support = require("@appium/support");

var _teen_process = require("teen_process");

var _lodash = _interopRequireDefault(require("lodash"));

var _asyncbox = require("asyncbox");

var _helpers = require("../helpers");

var _logger = _interopRequireDefault(require("../logger.js"));

const PROCESS_INIT_TIMEOUT = 5000;

const COMPANION_PGREP_PATTERN = udid => `${_helpers.IDB_COMPANION_EXECUTABLE}.*--udid[[:space:]]+${udid}`;

const COMPANION_STARTUP_REGEXP = /Started GRPC server on port (\d+)/;
const COMPANION_STARTUP_ERROR_REGEXP = /New Error Built ==> (.+)/;

function buildDaemonArgs(opts = {}) {
  const {
    port,
    grpcPort
  } = opts;
  const result = ['daemon'];

  if (port) {
    result.push('--port', port);
  }

  if (grpcPort) {
    result.push('--grpc-port', grpcPort);
  }

  return result;
}

const systemCallMethods = {};

systemCallMethods.connect = async function connect(opts = {}) {
  const {
    onlineTimeout
  } = opts;

  _logger.default.debug(`Connecting ${_helpers.IDB_EXECUTABLE} service to '${this.udid}'`);

  const binaryPaths = {};

  for (const binary of [_helpers.IDB_EXECUTABLE, _helpers.IDB_COMPANION_EXECUTABLE]) {
    try {
      binaryPaths[binary] = await _support.fs.which(binary);
    } catch (e) {
      throw new Error(`'${binary}' has not been found in PATH. ` + `Is it installed? Read https://www.fbidb.io for more details`);
    }
  }

  let grpcPort = _helpers.DEFAULT_COMPANION_GRPC_PORT;

  _logger.default.debug(`Starting companion: '${binaryPaths[_helpers.IDB_COMPANION_EXECUTABLE]}'`);

  const companionProc = new _teen_process.SubProcess(binaryPaths[_helpers.IDB_COMPANION_EXECUTABLE], ['--udid', this.udid]);
  let listeners = {
    'lines-stdout': null,
    'lines-stderr': null,
    exit: null
  };

  const cleanupListeners = () => {
    _lodash.default.toPairs(listeners).filter(([, v]) => _lodash.default.isFunction(v)).map(([k, v]) => companionProc.removeListener(k, v));

    listeners = {};
  };

  try {
    await companionProc.start(0);
    await new _bluebird.default((resolve, reject) => {
      for (const outType of ['stderr', 'stdout']) {
        const eventName = `lines-${outType}`;

        listeners[eventName] = lines => {
          for (const line of lines) {
            if (_lodash.default.isEmpty(_lodash.default.trim(line))) {
              continue;
            }

            if (this.verbose) {
              _logger.default.debug(`[${_helpers.IDB_COMPANION_EXECUTABLE} ${outType}] ${line}`);
            }

            const readyMatch = COMPANION_STARTUP_REGEXP.exec(line);

            if (readyMatch) {
              grpcPort = readyMatch[1];
              resolve();
            } else {
              const errorMatch = COMPANION_STARTUP_ERROR_REGEXP.exec(line);

              if (errorMatch) {
                reject(new Error(errorMatch[1]));
              }
            }
          }
        };

        companionProc.on(eventName, listeners[eventName]);
      }

      listeners.exit = (code, signal) => {
        cleanupListeners();
        const message = `${_helpers.IDB_COMPANION_EXECUTABLE} exited with code '${code}' from signal '${signal}'`;

        _logger.default.debug(message);

        reject(new Error(message));
      };

      companionProc.once('exit', listeners.exit);
    }).timeout(60000, 'Was unable to acquire a GRPC port after 60 seconds timeout');
  } catch (err) {
    cleanupListeners();

    if (companionProc.isRunning) {
      try {
        await companionProc.stop();
      } catch (ign) {}
    }

    _logger.default.error(`Failed to start ${_helpers.IDB_COMPANION_EXECUTABLE}: ${err.message}`);

    throw err;
  }

  _logger.default.debug(`${_helpers.IDB_COMPANION_EXECUTABLE} is listening on GRPC port '${grpcPort}'`);

  try {
    try {
      await (0, _teen_process.exec)(_helpers.IDB_EXECUTABLE, ['connect', '127.0.0.1', grpcPort]);
    } catch (connectionError) {
      await (0, _asyncbox.retryInterval)(2, 100, async () => {
        await this.disconnect();

        try {
          await (0, _teen_process.exec)(_helpers.IDB_EXECUTABLE, ['kill']);
        } catch (ign) {}

        let isStartupMonitorEnabled = true;

        try {
          const daemon = new _teen_process.SubProcess(_helpers.IDB_EXECUTABLE, buildDaemonArgs({
            port: this.executable.port,
            grpcPort
          }));
          let daemonOutput = '';
          daemon.on('output', (stdout, stderr) => {
            if (isStartupMonitorEnabled && _lodash.default.trim(stdout || stderr)) {
              daemonOutput += `[daemon] ${stdout || stderr}\n`;
            }
          });

          try {
            await daemon.start(null, PROCESS_INIT_TIMEOUT);
            await _bluebird.default.delay(300);
          } catch (ign) {}

          if (daemon.isRunning) {
            _logger.default.debug(`${_helpers.IDB_EXECUTABLE} daemon started on port ${this.executable.port || _helpers.DEFAULT_IDB_PORT}`);
          } else {
            if (!daemonOutput.includes('address already in use')) {
              const message = `${_helpers.IDB_EXECUTABLE} daemon has failed to start: ${daemonOutput}`;

              _logger.default.warn(message);

              throw new Error(message);
            }

            _logger.default.debug(`The port ${this.executable.port || _helpers.DEFAULT_IDB_PORT} is already in use. ` + `Assuming it is used by ${_helpers.IDB_EXECUTABLE} daemon`);
          }

          await (0, _teen_process.exec)(_helpers.IDB_EXECUTABLE, ['connect', '127.0.0.1', grpcPort]);
        } catch (connectionError2) {
          if (connectionError2.stderr || connectionError2.stdout) {
            _logger.default.debug(connectionError2.stderr || connectionError2.stdout);
          }

          throw connectionError2;
        } finally {
          isStartupMonitorEnabled = false;
        }
      });
    }
  } catch (e) {
    if (e.stderr) {
      _logger.default.debug(e.stderr);
    }

    throw new Error(`Cannot start ${_helpers.IDB_EXECUTABLE} service for '${this.udid}'. ` + `Check the server log for more details.`);
  }

  _logger.default.info(`Successfully established the connection to ${_helpers.IDB_EXECUTABLE} service for '${this.udid}'`);

  if (onlineTimeout) {
    await this.waitForDevice(onlineTimeout);
  }

  this.executable.path = binaryPaths[_helpers.IDB_EXECUTABLE];
  this.companion.path = binaryPaths[_helpers.IDB_COMPANION_EXECUTABLE];
};

systemCallMethods.waitForDevice = async function waitForDevice(timeoutMs = 10000) {
  if (!timeoutMs) {
    _logger.default.debug('No timeout is provided, so not waiting until the device is online');

    return;
  }

  _logger.default.debug(`Waiting up to ${timeoutMs}ms for the device to be online`);

  const timer = new _support.timing.Timer().start();

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        await this.exec(['ui', 'describe-all']);
        return true;
      } catch (e) {
        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 300
    });
  } catch (e) {
    throw new Error(`The device '${this.udid}' is not responding to idb requests after ${timeoutMs}ms timeout. ` + `Original error: ${e.stderr || e.message}`);
  }

  _logger.default.debug(`The device '${this.udid}' is online and ready to accept idb commands in ` + `${timer.getDuration().asSeconds.toFixed(3)}s`);
};

systemCallMethods.disconnect = async function disconnect() {
  _logger.default.debug(`Disconnecting ${_helpers.IDB_EXECUTABLE} service from '${this.udid}'`);

  try {
    await (0, _teen_process.exec)(this.executable.path, ['disconnect', this.udid]);
  } catch (ign) {}

  const companionPids = await (0, _helpers.getPids)(COMPANION_PGREP_PATTERN(this.udid));

  if (_lodash.default.isEmpty(companionPids)) {
    return;
  }

  _logger.default.debug(`Cleaning up ${companionPids.length} obsolete ${_helpers.IDB_COMPANION_EXECUTABLE} ` + `process${companionPids.length === 1 ? '' : 'es'}`);

  await (0, _teen_process.exec)('kill', ['-2', ...companionPids]);
};

systemCallMethods.exec = async function exec(cmd, args = [], opts = {}) {
  if (!cmd) {
    throw new Error('You need to pass in a command to exec()');
  }

  cmd = _lodash.default.isArray(cmd) ? cmd : [cmd];
  opts = _lodash.default.cloneDeep(opts);
  opts.timeout = opts.timeout || this.execTimeout || _helpers.DEFAULT_IDB_EXEC_TIMEOUT;
  opts.timeoutCapName = opts.timeoutCapName || 'execTimeout';
  const fullArgs = [...cmd, ...this.executable.defaultArgs, ...args];

  _logger.default.debug(`Running '${this.executable.path} ${_support.util.quote(fullArgs)}'`);

  try {
    const {
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, fullArgs, opts);
    return stdout;
  } catch (e) {
    if (_support.util.hasValue(e.code)) {
      e.message = `Error executing ${_helpers.IDB_EXECUTABLE}. Original error: '${e.message}'; ` + `Stdout: '${(e.stdout || '').trim()}'; ` + `Stderr: '${(e.stderr || '').trim()}'; ` + `Code: '${e.code}'`;
    } else {
      e.message = `Error executing ${_helpers.IDB_EXECUTABLE}. Original error: '${e.message}'. ` + `Try to increase the ${opts.timeout}ms ${_helpers.IDB_EXECUTABLE} execution timeout represented by '${opts.timeoutCapName}' capability`;
    }

    throw e;
  }
};

systemCallMethods.createSubProcess = function createSubProcess(command = [], args = [], opts = {}) {
  const idbArgs = [...command, ...this.executable.defaultArgs, ...args];

  _logger.default.debug(`Creating ${_helpers.IDB_EXECUTABLE} subprocess with args: ${_support.util.quote(args)}`);

  return new _teen_process.SubProcess(this.executable.path, idbArgs, opts);
};

var _default = systemCallMethods;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY29tbWFuZHMuanMiXSwibmFtZXMiOlsiUFJPQ0VTU19JTklUX1RJTUVPVVQiLCJDT01QQU5JT05fUEdSRVBfUEFUVEVSTiIsInVkaWQiLCJJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEUiLCJDT01QQU5JT05fU1RBUlRVUF9SRUdFWFAiLCJDT01QQU5JT05fU1RBUlRVUF9FUlJPUl9SRUdFWFAiLCJidWlsZERhZW1vbkFyZ3MiLCJvcHRzIiwicG9ydCIsImdycGNQb3J0IiwicmVzdWx0IiwicHVzaCIsInN5c3RlbUNhbGxNZXRob2RzIiwiY29ubmVjdCIsIm9ubGluZVRpbWVvdXQiLCJsb2ciLCJkZWJ1ZyIsIklEQl9FWEVDVVRBQkxFIiwiYmluYXJ5UGF0aHMiLCJiaW5hcnkiLCJmcyIsIndoaWNoIiwiZSIsIkVycm9yIiwiREVGQVVMVF9DT01QQU5JT05fR1JQQ19QT1JUIiwiY29tcGFuaW9uUHJvYyIsIlN1YlByb2Nlc3MiLCJsaXN0ZW5lcnMiLCJleGl0IiwiY2xlYW51cExpc3RlbmVycyIsIl8iLCJ0b1BhaXJzIiwiZmlsdGVyIiwidiIsImlzRnVuY3Rpb24iLCJtYXAiLCJrIiwicmVtb3ZlTGlzdGVuZXIiLCJzdGFydCIsIkIiLCJyZXNvbHZlIiwicmVqZWN0Iiwib3V0VHlwZSIsImV2ZW50TmFtZSIsImxpbmVzIiwibGluZSIsImlzRW1wdHkiLCJ0cmltIiwidmVyYm9zZSIsInJlYWR5TWF0Y2giLCJleGVjIiwiZXJyb3JNYXRjaCIsIm9uIiwiY29kZSIsInNpZ25hbCIsIm1lc3NhZ2UiLCJvbmNlIiwidGltZW91dCIsImVyciIsImlzUnVubmluZyIsInN0b3AiLCJpZ24iLCJlcnJvciIsImNvbm5lY3Rpb25FcnJvciIsImRpc2Nvbm5lY3QiLCJpc1N0YXJ0dXBNb25pdG9yRW5hYmxlZCIsImRhZW1vbiIsImV4ZWN1dGFibGUiLCJkYWVtb25PdXRwdXQiLCJzdGRvdXQiLCJzdGRlcnIiLCJkZWxheSIsIkRFRkFVTFRfSURCX1BPUlQiLCJpbmNsdWRlcyIsIndhcm4iLCJjb25uZWN0aW9uRXJyb3IyIiwiaW5mbyIsIndhaXRGb3JEZXZpY2UiLCJwYXRoIiwiY29tcGFuaW9uIiwidGltZW91dE1zIiwidGltZXIiLCJ0aW1pbmciLCJUaW1lciIsIndhaXRNcyIsImludGVydmFsTXMiLCJnZXREdXJhdGlvbiIsImFzU2Vjb25kcyIsInRvRml4ZWQiLCJjb21wYW5pb25QaWRzIiwibGVuZ3RoIiwiY21kIiwiYXJncyIsImlzQXJyYXkiLCJjbG9uZURlZXAiLCJleGVjVGltZW91dCIsIkRFRkFVTFRfSURCX0VYRUNfVElNRU9VVCIsInRpbWVvdXRDYXBOYW1lIiwiZnVsbEFyZ3MiLCJkZWZhdWx0QXJncyIsInV0aWwiLCJxdW90ZSIsImhhc1ZhbHVlIiwiY3JlYXRlU3ViUHJvY2VzcyIsImNvbW1hbmQiLCJpZGJBcmdzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUlBOztBQUdBLE1BQU1BLG9CQUFvQixHQUFHLElBQTdCOztBQUNBLE1BQU1DLHVCQUF1QixHQUFJQyxJQUFELElBQzdCLEdBQUVDLGlDQUF5Qix1QkFBc0JELElBQUssRUFEekQ7O0FBRUEsTUFBTUUsd0JBQXdCLEdBQUcsbUNBQWpDO0FBQ0EsTUFBTUMsOEJBQThCLEdBQUcsMEJBQXZDOztBQUVBLFNBQVNDLGVBQVQsQ0FBMEJDLElBQUksR0FBRyxFQUFqQyxFQUFxQztBQUNuQyxRQUFNO0FBQ0pDLElBQUFBLElBREk7QUFFSkMsSUFBQUE7QUFGSSxNQUdGRixJQUhKO0FBS0EsUUFBTUcsTUFBTSxHQUFHLENBQUMsUUFBRCxDQUFmOztBQUNBLE1BQUlGLElBQUosRUFBVTtBQUNSRSxJQUFBQSxNQUFNLENBQUNDLElBQVAsQ0FBWSxRQUFaLEVBQXNCSCxJQUF0QjtBQUNEOztBQUNELE1BQUlDLFFBQUosRUFBYztBQUNaQyxJQUFBQSxNQUFNLENBQUNDLElBQVAsQ0FBWSxhQUFaLEVBQTJCRixR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LENBQUNqQyxDQUFDLENBQUMrQyxNQUFGLElBQVksRUFBYixFQUFpQnRCLElBQWpCLEVBQXdCLEtBRDFCLEdBRVQsWUFBVyxDQUFDekIsQ0FBQyxDQUFDZ0QsTUFBRixJQUFZLEVBQWIsRUFBaUJ2QixJQUFqQixFQUF3QixLQUYxQixHQUdULFVBQVN6QixDQUFDLENBQUMrQixJQUFLLEdBSG5CO0FBSUQsS0FMRCxNQUtPO0FBQ0wvQixNQUFBQSxDQUFDLENBQUNpQyxPQUFGLEdBQWEsbUJBQWtCdEMsdUJBQWUsc0JBQXFCSyxDQUFDLENBQUNpQyxPQUFRLEtBQWpFLEdBQ1QsdUJBQXNCaEQsSUFBSSxDQUFDa0QsT0FBUSxNQUFLeEMsdUJBQWUsc0NBQXFDVixJQUFJLENBQUMwRixjQUFlLGNBRG5IO0FBRUQ7O0FBQ0QsVUFBTTNFLENBQU47QUFDRDtBQUNGLENBNUJEOztBQXNDQVYsaUJBQWlCLENBQUMyRixnQkFBbEIsR0FBcUMsU0FBU0EsZ0JBQVQsQ0FBMkJDLE9BQU8sR0FBRyxFQUFyQyxFQUF5Q1osSUFBSSxHQUFHLEVBQWhELEVBQW9EckYsSUFBSSxHQUFHLEVBQTNELEVBQStEO0FBQ2xHLFFBQU1rRyxPQUFPLEdBQUcsQ0FBQyxHQUFHRCxPQUFKLEVBQWEsR0FBRyxLQUFLckMsVUFBTCxDQUFnQmdDLFdBQWhDLEVBQTZDLEdBQUdQLElBQWhELENBQWhCOztBQUNBN0Usa0JBQUlDLEtBQUosQ0FBVyxZQUFXQyx1QkFBZSwwQkFBeUJtRixjQUFLQyxLQUFMLENBQVdULElBQVgsQ0FBaUIsRUFBL0U7O0FBQ0EsU0FBTyxJQUFJbEUsd0JBQUosQ0FBZSxLQUFLeUMsVUFBTCxDQUFnQlcsSUFBL0IsRUFBcUMyQixPQUFyQyxFQUE4Q2xHLElBQTlDLENBQVA7QUFDRCxDQUpEOztlQU1lSyxpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IGZzLCB1dGlsLCB0aW1pbmcgfSBmcm9tICdAYXBwaXVtL3N1cHBvcnQnO1xuaW1wb3J0IHsgZXhlYyBhcyB0cEV4ZWMsIFN1YlByb2Nlc3MgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHJldHJ5SW50ZXJ2YWwsIHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQge1xuICBnZXRQaWRzLCBERUZBVUxUX0lEQl9FWEVDX1RJTUVPVVQsIElEQl9FWEVDVVRBQkxFLFxuICBJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEUsIERFRkFVTFRfSURCX1BPUlQsIERFRkFVTFRfQ09NUEFOSU9OX0dSUENfUE9SVCxcbn0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlci5qcyc7XG5cblxuY29uc3QgUFJPQ0VTU19JTklUX1RJTUVPVVQgPSA1MDAwO1xuY29uc3QgQ09NUEFOSU9OX1BHUkVQX1BBVFRFUk4gPSAodWRpZCkgPT5cbiAgYCR7SURCX0NPTVBBTklPTl9FWEVDVVRBQkxFfS4qLS11ZGlkW1s6c3BhY2U6XV0rJHt1ZGlkfWA7XG5jb25zdCBDT01QQU5JT05fU1RBUlRVUF9SRUdFWFAgPSAvU3RhcnRlZCBHUlBDIHNlcnZlciBvbiBwb3J0IChcXGQrKS87XG5jb25zdCBDT01QQU5JT05fU1RBUlRVUF9FUlJPUl9SRUdFWFAgPSAvTmV3IEVycm9yIEJ1aWx0ID09PiAoLispLztcblxuZnVuY3Rpb24gYnVpbGREYWVtb25BcmdzIChvcHRzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHBvcnQsXG4gICAgZ3JwY1BvcnQsXG4gIH0gPSBvcHRzO1xuXG4gIGNvbnN0IHJlc3VsdCA9IFsnZGFlbW9uJ107XG4gIGlmIChwb3J0KSB7XG4gICAgcmVzdWx0LnB1c2goJy0tcG9ydCcsIHBvcnQpO1xuICB9XG4gIGlmIChncnBjUG9ydCkge1xuICAgIHJlc3VsdC5wdXNoKCctLWdycGMtcG9ydCcsIGdycGNQb3J0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmNvbnN0IHN5c3RlbUNhbGxNZXRob2RzID0ge307XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29ubmVjdE9wdGlvbnNcbiAqXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IG9ubGluZVRpbWVvdXQgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0XG4gKiB1bnRpbCB0aGUgZGV2aWNlIHVuZGVyIHRlc3RzIGlzIG9ubGluZS4gTm8gd2FpdCBpcyBnb2luZyB0byBiZSBwZXJmb3JtZWRcbiAqIGlmIHRoZSB0aW1lb3V0IGlzIG5vdCBzZXQuIEl0IGlzIHJlY29tbWVuZGVkIHRvIHByb3ZpZGUgdGhpcyB2YWx1ZSBpZlxuICogYGNvbm5lY3RgIGlzIGNhbGxlZCByaWdodCBhZnRlciBkZXZpY2UgaXMgYm9vdGVkLCBzbyBub3QgYWxsIHRoZSByZXF1aXJlZFxuICogZGV2aWNlIHNlcnZpY2VzIGhhdmUgYmVlbiBzdGFydGVkIHlldC5cbiAqL1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGlkYiBhbmQgY29tcGFuaW9uIHByb2Nlc3NlcyBpZiBuZWNlc3NhcnkgYW5kXG4gKiBhc3NpZ25zIHBhdGggcHJvcGVydGllcy4gSXQgaXMgbWFuZGF0b3J5IHRvIGNhbGwgdGhpcyBtZXRob2QgYmVmb3JlXG4gKiBvbmUgY2FuIHN0YXJ0IHVzaW5nIElEQiBpbnN0YW5jZSxcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbWFuZGF0b3J5IGlkYiBleGVjdXRhYmxlcyBhcmUgbm90IHByZXNlbnQgb24gdGhlXG4gKiBsb2NhbGhvc3Qgb3IgdGhlcmUgd2FzIGEgZmFpbHVyZSB3aGlsZSBzdGFydGluZy9kZXRlY3RpbmcgdGhlbVxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5jb25uZWN0ID0gYXN5bmMgZnVuY3Rpb24gY29ubmVjdCAob3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBvbmxpbmVUaW1lb3V0LFxuICB9ID0gb3B0cztcblxuICBsb2cuZGVidWcoYENvbm5lY3RpbmcgJHtJREJfRVhFQ1VUQUJMRX0gc2VydmljZSB0byAnJHt0aGlzLnVkaWR9J2ApO1xuXG4gIGNvbnN0IGJpbmFyeVBhdGhzID0ge307XG4gIGZvciAoY29uc3QgYmluYXJ5IG9mIFtJREJfRVhFQ1VUQUJMRSwgSURCX0NPTVBBTklPTl9FWEVDVVRBQkxFXSkge1xuICAgIHRyeSB7XG4gICAgICBiaW5hcnlQYXRoc1tiaW5hcnldID0gYXdhaXQgZnMud2hpY2goYmluYXJ5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2JpbmFyeX0nIGhhcyBub3QgYmVlbiBmb3VuZCBpbiBQQVRILiBgICtcbiAgICAgICAgYElzIGl0IGluc3RhbGxlZD8gUmVhZCBodHRwczovL3d3dy5mYmlkYi5pbyBmb3IgbW9yZSBkZXRhaWxzYCk7XG4gICAgfVxuICB9XG5cbiAgbGV0IGdycGNQb3J0ID0gREVGQVVMVF9DT01QQU5JT05fR1JQQ19QT1JUO1xuICBsb2cuZGVidWcoYFN0YXJ0aW5nIGNvbXBhbmlvbjogJyR7YmluYXJ5UGF0aHNbSURCX0NPTVBBTklPTl9FWEVDVVRBQkxFXX0nYCk7XG4gIGNvbnN0IGNvbXBhbmlvblByb2MgPSBuZXcgU3ViUHJvY2VzcyhiaW5hcnlQYXRoc1tJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEVdLCBbJy0tdWRpZCcsIHRoaXMudWRpZF0pO1xuICBsZXQgbGlzdGVuZXJzID0ge1xuICAgICdsaW5lcy1zdGRvdXQnOiBudWxsLFxuICAgICdsaW5lcy1zdGRlcnInOiBudWxsLFxuICAgIGV4aXQ6IG51bGwsXG4gIH07XG4gIGNvbnN0IGNsZWFudXBMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgXy50b1BhaXJzKGxpc3RlbmVycylcbiAgICAgIC5maWx0ZXIoKFssIHZdKSA9PiBfLmlzRnVuY3Rpb24odikpXG4gICAgICAubWFwKChbaywgdl0pID0+IGNvbXBhbmlvblByb2MucmVtb3ZlTGlzdGVuZXIoaywgdikpO1xuICAgIGxpc3RlbmVycyA9IHt9O1xuICB9O1xuICB0cnkge1xuICAgIGF3YWl0IGNvbXBhbmlvblByb2Muc3RhcnQoMCk7XG5cbiAgICBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG91dFR5cGUgb2YgWydzdGRlcnInLCAnc3Rkb3V0J10pIHtcbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gYGxpbmVzLSR7b3V0VHlwZX1gO1xuICAgICAgICBsaXN0ZW5lcnNbZXZlbnROYW1lXSA9IChsaW5lcykgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgaWYgKF8uaXNFbXB0eShfLnRyaW0obGluZSkpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgIGxvZy5kZWJ1ZyhgWyR7SURCX0NPTVBBTklPTl9FWEVDVVRBQkxFfSAke291dFR5cGV9XSAke2xpbmV9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBtYXJrZXIgdGhhdCB0aGluZ3MgYXJlIHJlYWR5IHRvIGdvXG4gICAgICAgICAgICBjb25zdCByZWFkeU1hdGNoID0gQ09NUEFOSU9OX1NUQVJUVVBfUkVHRVhQLmV4ZWMobGluZSk7XG4gICAgICAgICAgICBpZiAocmVhZHlNYXRjaCkge1xuICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBwb3J0IGFuZCBzYXZlLCBzbyBpZGIgY2FuIGNvbm5lY3RcbiAgICAgICAgICAgICAgZ3JwY1BvcnQgPSByZWFkeU1hdGNoWzFdO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBoYXMgYmVlbiBhbiBlcnJvclxuICAgICAgICAgICAgICBjb25zdCBlcnJvck1hdGNoID0gQ09NUEFOSU9OX1NUQVJUVVBfRVJST1JfUkVHRVhQLmV4ZWMobGluZSk7XG4gICAgICAgICAgICAgIGlmIChlcnJvck1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvck1hdGNoWzFdKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbXBhbmlvblByb2Mub24oZXZlbnROYW1lLCBsaXN0ZW5lcnNbZXZlbnROYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycy5leGl0ID0gKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXJzKCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHtJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEV9IGV4aXRlZCB3aXRoIGNvZGUgJyR7Y29kZX0nIGZyb20gc2lnbmFsICcke3NpZ25hbH0nYDtcbiAgICAgICAgbG9nLmRlYnVnKG1lc3NhZ2UpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICAgIH07XG4gICAgICBjb21wYW5pb25Qcm9jLm9uY2UoJ2V4aXQnLCBsaXN0ZW5lcnMuZXhpdCk7XG4gICAgfSkudGltZW91dCg2MDAwMCwgJ1dhcyB1bmFibGUgdG8gYWNxdWlyZSBhIEdSUEMgcG9ydCBhZnRlciA2MCBzZWNvbmRzIHRpbWVvdXQnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2xlYW51cExpc3RlbmVycygpO1xuICAgIGlmIChjb21wYW5pb25Qcm9jLmlzUnVubmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY29tcGFuaW9uUHJvYy5zdG9wKCk7XG4gICAgICB9IGNhdGNoIChpZ24pIHt9XG4gICAgfVxuICAgIGxvZy5lcnJvcihgRmFpbGVkIHRvIHN0YXJ0ICR7SURCX0NPTVBBTklPTl9FWEVDVVRBQkxFfTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICBsb2cuZGVidWcoYCR7SURCX0NPTVBBTklPTl9FWEVDVVRBQkxFfSBpcyBsaXN0ZW5pbmcgb24gR1JQQyBwb3J0ICcke2dycGNQb3J0fSdgKTtcblxuICB0cnkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0cEV4ZWMoSURCX0VYRUNVVEFCTEUsIFsnY29ubmVjdCcsICcxMjcuMC4wLjEnLCBncnBjUG9ydF0pO1xuICAgIH0gY2F0Y2ggKGNvbm5lY3Rpb25FcnJvcikge1xuICAgICAgYXdhaXQgcmV0cnlJbnRlcnZhbCgyLCAxMDAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdHBFeGVjKElEQl9FWEVDVVRBQkxFLCBbJ2tpbGwnXSk7XG4gICAgICAgIH0gY2F0Y2ggKGlnbikge31cbiAgICAgICAgbGV0IGlzU3RhcnR1cE1vbml0b3JFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkYWVtb24gPSBuZXcgU3ViUHJvY2VzcyhJREJfRVhFQ1VUQUJMRSwgYnVpbGREYWVtb25BcmdzKHtcbiAgICAgICAgICAgIHBvcnQ6IHRoaXMuZXhlY3V0YWJsZS5wb3J0LFxuICAgICAgICAgICAgZ3JwY1BvcnQsXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGxldCBkYWVtb25PdXRwdXQgPSAnJztcbiAgICAgICAgICBkYWVtb24ub24oJ291dHB1dCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzU3RhcnR1cE1vbml0b3JFbmFibGVkICYmIF8udHJpbShzdGRvdXQgfHwgc3RkZXJyKSkge1xuICAgICAgICAgICAgICBkYWVtb25PdXRwdXQgKz0gYFtkYWVtb25dICR7c3Rkb3V0IHx8IHN0ZGVycn1cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBkYWVtb24uc3RhcnQobnVsbCwgUFJPQ0VTU19JTklUX1RJTUVPVVQpO1xuICAgICAgICAgICAgYXdhaXQgQi5kZWxheSgzMDApO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbikge31cblxuICAgICAgICAgIGlmIChkYWVtb24uaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoYCR7SURCX0VYRUNVVEFCTEV9IGRhZW1vbiBzdGFydGVkIG9uIHBvcnQgJHt0aGlzLmV4ZWN1dGFibGUucG9ydCB8fCBERUZBVUxUX0lEQl9QT1JUfWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWRhZW1vbk91dHB1dC5pbmNsdWRlcygnYWRkcmVzcyBhbHJlYWR5IGluIHVzZScpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHtJREJfRVhFQ1VUQUJMRX0gZGFlbW9uIGhhcyBmYWlsZWQgdG8gc3RhcnQ6ICR7ZGFlbW9uT3V0cHV0fWA7XG4gICAgICAgICAgICAgIGxvZy53YXJuKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2cuZGVidWcoYFRoZSBwb3J0ICR7dGhpcy5leGVjdXRhYmxlLnBvcnQgfHwgREVGQVVMVF9JREJfUE9SVH0gaXMgYWxyZWFkeSBpbiB1c2UuIGAgK1xuICAgICAgICAgICAgICBgQXNzdW1pbmcgaXQgaXMgdXNlZCBieSAke0lEQl9FWEVDVVRBQkxFfSBkYWVtb25gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgdHBFeGVjKElEQl9FWEVDVVRBQkxFLCBbJ2Nvbm5lY3QnLCAnMTI3LjAuMC4xJywgZ3JwY1BvcnRdKTtcbiAgICAgICAgfSBjYXRjaCAoY29ubmVjdGlvbkVycm9yMikge1xuICAgICAgICAgIGlmIChjb25uZWN0aW9uRXJyb3IyLnN0ZGVyciB8fCBjb25uZWN0aW9uRXJyb3IyLnN0ZG91dCkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKGNvbm5lY3Rpb25FcnJvcjIuc3RkZXJyIHx8IGNvbm5lY3Rpb25FcnJvcjIuc3Rkb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yMjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpc1N0YXJ0dXBNb25pdG9yRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5zdGRlcnIpIHtcbiAgICAgIGxvZy5kZWJ1ZyhlLnN0ZGVycik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHN0YXJ0ICR7SURCX0VYRUNVVEFCTEV9IHNlcnZpY2UgZm9yICcke3RoaXMudWRpZH0nLiBgICtcbiAgICAgIGBDaGVjayB0aGUgc2VydmVyIGxvZyBmb3IgbW9yZSBkZXRhaWxzLmApO1xuICB9XG4gIGxvZy5pbmZvKGBTdWNjZXNzZnVsbHkgZXN0YWJsaXNoZWQgdGhlIGNvbm5lY3Rpb24gdG8gJHtJREJfRVhFQ1VUQUJMRX0gc2VydmljZSBmb3IgJyR7dGhpcy51ZGlkfSdgKTtcblxuICBpZiAob25saW5lVGltZW91dCkge1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckRldmljZShvbmxpbmVUaW1lb3V0KTtcbiAgfVxuXG4gIHRoaXMuZXhlY3V0YWJsZS5wYXRoID0gYmluYXJ5UGF0aHNbSURCX0VYRUNVVEFCTEVdO1xuICB0aGlzLmNvbXBhbmlvbi5wYXRoID0gYmluYXJ5UGF0aHNbSURCX0NPTVBBTklPTl9FWEVDVVRBQkxFXTtcbn07XG5cbi8qKlxuICogQmxvY2tzIHVudGlsIHRoZSBkZXZpY2UgdW5kZXIgdGVzdCBzdGFydHMgcmVzcG9uZGluZyB0byBpZGIgY29tbWFuZHMuXG4gKiBUaGUgZGV2aWNlIG11c3QgYmUgYm9vdGVkL29ubGluZSBhbmQgaWRiIG11c3QgYmUgYWxyZWFkeSBjb25uZWN0ZWQgZm9yIHRoYXQgdG8gaGFwcGVuXG4gKlxuICogQHBhcmFtIHs/bnVtYmVyfSB0aW1lb3V0TXMgWzEwMDAwXSAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAqIHVudGlsIHRoZSBkZXZpY2UgdW5kZXIgdGVzdHMgaXMgb25saW5lLiBUaGUgbWV0aG9kIHdpbGwgcmV0dXJuIGltbWVkaWF0ZWx5XG4gKiBpZiB0aGUgdGltZW91dCBpcyBmYWxzeVxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBkZXZpY2UgaXMgbm90IHJlc3BvbmRpbmcgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0XG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLndhaXRGb3JEZXZpY2UgPSBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yRGV2aWNlICh0aW1lb3V0TXMgPSAxMDAwMCkge1xuICBpZiAoIXRpbWVvdXRNcykge1xuICAgIGxvZy5kZWJ1ZygnTm8gdGltZW91dCBpcyBwcm92aWRlZCwgc28gbm90IHdhaXRpbmcgdW50aWwgdGhlIGRldmljZSBpcyBvbmxpbmUnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsb2cuZGVidWcoYFdhaXRpbmcgdXAgdG8gJHt0aW1lb3V0TXN9bXMgZm9yIHRoZSBkZXZpY2UgdG8gYmUgb25saW5lYCk7XG4gIGNvbnN0IHRpbWVyID0gbmV3IHRpbWluZy5UaW1lcigpLnN0YXJ0KCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmV4ZWMoWyd1aScsICdkZXNjcmliZS1hbGwnXSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0TXMsXG4gICAgICBpbnRlcnZhbE1zOiAzMDAsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBkZXZpY2UgJyR7dGhpcy51ZGlkfScgaXMgbm90IHJlc3BvbmRpbmcgdG8gaWRiIHJlcXVlc3RzIGFmdGVyICR7dGltZW91dE1zfW1zIHRpbWVvdXQuIGAgK1xuICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2Uuc3RkZXJyIHx8IGUubWVzc2FnZX1gKTtcbiAgfVxuICBsb2cuZGVidWcoYFRoZSBkZXZpY2UgJyR7dGhpcy51ZGlkfScgaXMgb25saW5lIGFuZCByZWFkeSB0byBhY2NlcHQgaWRiIGNvbW1hbmRzIGluIGAgK1xuICAgIGAke3RpbWVyLmdldER1cmF0aW9uKCkuYXNTZWNvbmRzLnRvRml4ZWQoMyl9c2ApO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBjbGVhbnVwIG9mIG9ic29sZXRlIGNvbXBhbmlvbiBwcm9jZXNzZXNcbiAqIFRoZSBkYWVtb24gcHJvY2VzcyBpcyBsZWZ0IHVudG91Y2hlZCwgYmVjYXVzZSBraWxsaW5nIGl0IG1pZ2h0XG4gKiBwb3RlbnRpYWxseSBhZmZlY3Qgb3RoZXIgcGFyYWxsZWwgc2Vzc2lvbnMuIE5vdGhpbmdcbiAqIGlzIGRvbmUgaWYgbm8gb2Jzb2xldGUgcHJvY2Vzc2VzIGFyZSBmb3VuZC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZGlzY29ubmVjdCA9IGFzeW5jIGZ1bmN0aW9uIGRpc2Nvbm5lY3QgKCkge1xuICBsb2cuZGVidWcoYERpc2Nvbm5lY3RpbmcgJHtJREJfRVhFQ1VUQUJMRX0gc2VydmljZSBmcm9tICcke3RoaXMudWRpZH0nYCk7XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCB0cEV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIFsnZGlzY29ubmVjdCcsIHRoaXMudWRpZF0pO1xuICB9IGNhdGNoIChpZ24pIHt9XG5cbiAgY29uc3QgY29tcGFuaW9uUGlkcyA9IGF3YWl0IGdldFBpZHMoQ09NUEFOSU9OX1BHUkVQX1BBVFRFUk4odGhpcy51ZGlkKSk7XG4gIGlmIChfLmlzRW1wdHkoY29tcGFuaW9uUGlkcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsb2cuZGVidWcoYENsZWFuaW5nIHVwICR7Y29tcGFuaW9uUGlkcy5sZW5ndGh9IG9ic29sZXRlICR7SURCX0NPTVBBTklPTl9FWEVDVVRBQkxFfSBgICtcbiAgICBgcHJvY2VzcyR7Y29tcGFuaW9uUGlkcy5sZW5ndGggPT09IDEgPyAnJyA6ICdlcyd9YCk7XG4gIGF3YWl0IHRwRXhlYygna2lsbCcsIFsnLTInLCAuLi5jb21wYW5pb25QaWRzXSk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGdpdmVuIGlkYiBjb21tYW5kLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNtZCAtIFRoZSBhY3R1YWwgaWRiIGNvbW1hbmQgd2l0aG91dCBhcmd1bWVudHMvcGFyYW1zLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhcmdzIC0gT3B0aW9uYWwgY29tbWFuZCBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBtYXBwaW5nLiBTZWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vbm9kZS10ZWVuX3Byb2Nlc3N9XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gQ29tbWFuZCdzIHN0ZG91dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29tbWFuZCByZXR1cm5lZCBub24temVybyBleGl0IGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmV4ZWMgPSBhc3luYyBmdW5jdGlvbiBleGVjIChjbWQsIGFyZ3MgPSBbXSwgb3B0cyA9IHt9KSB7XG4gIGlmICghY21kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBwYXNzIGluIGEgY29tbWFuZCB0byBleGVjKCknKTtcbiAgfVxuICBjbWQgPSBfLmlzQXJyYXkoY21kKSA/IGNtZCA6IFtjbWRdO1xuXG4gIG9wdHMgPSBfLmNsb25lRGVlcChvcHRzKTtcbiAgLy8gc2V0dGluZyBkZWZhdWx0IHRpbWVvdXQgZm9yIGVhY2ggY29tbWFuZCB0byBwcmV2ZW50IGluZmluaXRlIHdhaXQuXG4gIG9wdHMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCB0aGlzLmV4ZWNUaW1lb3V0IHx8IERFRkFVTFRfSURCX0VYRUNfVElNRU9VVDtcbiAgb3B0cy50aW1lb3V0Q2FwTmFtZSA9IG9wdHMudGltZW91dENhcE5hbWUgfHwgJ2V4ZWNUaW1lb3V0JzsgLy8gRm9yIGVycm9yIG1lc3NhZ2VcblxuICBjb25zdCBmdWxsQXJncyA9IFsuLi5jbWQsIC4uLnRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncywgLi4uYXJnc107XG4gIGxvZy5kZWJ1ZyhgUnVubmluZyAnJHt0aGlzLmV4ZWN1dGFibGUucGF0aH0gJHt1dGlsLnF1b3RlKGZ1bGxBcmdzKX0nYCk7XG4gIHRyeSB7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCB0cEV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIGZ1bGxBcmdzLCBvcHRzKTtcbiAgICByZXR1cm4gc3Rkb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHV0aWwuaGFzVmFsdWUoZS5jb2RlKSkge1xuICAgICAgZS5tZXNzYWdlID0gYEVycm9yIGV4ZWN1dGluZyAke0lEQl9FWEVDVVRBQkxFfS4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgYFN0ZG91dDogJyR7KGUuc3Rkb3V0IHx8ICcnKS50cmltKCl9JzsgYCArXG4gICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IGAgK1xuICAgICAgICBgQ29kZTogJyR7ZS5jb2RlfSdgO1xuICAgIH0gZWxzZSB7XG4gICAgICBlLm1lc3NhZ2UgPSBgRXJyb3IgZXhlY3V0aW5nICR7SURCX0VYRUNVVEFCTEV9LiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfScuIGAgK1xuICAgICAgICBgVHJ5IHRvIGluY3JlYXNlIHRoZSAke29wdHMudGltZW91dH1tcyAke0lEQl9FWEVDVVRBQkxFfSBleGVjdXRpb24gdGltZW91dCByZXByZXNlbnRlZCBieSAnJHtvcHRzLnRpbWVvdXRDYXBOYW1lfScgY2FwYWJpbGl0eWA7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTdWJQcm9jZXNzIGluc3RhbmNlIG9mIGlkYiBmb3IgYmFja2dyb3VuZFxuICogZXhlY3V0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gY29tbWFuZCBkZXNpcmVkIGlkYiBjb21tYW5kIChlLmcuOiBbXCJsYXVuY2hcIl0sIFtcInhjdGVzdFwiLCBcInJ1blwiLCBcInVpXCJdKVxuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBhcmdzIGFkZGl0aW9uYWwgaWRiIGFyZ3VtZW50c1xuICogQHJldHVybnMge1N1YlByb2Nlc3N9XG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmNyZWF0ZVN1YlByb2Nlc3MgPSBmdW5jdGlvbiBjcmVhdGVTdWJQcm9jZXNzIChjb21tYW5kID0gW10sIGFyZ3MgPSBbXSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGlkYkFyZ3MgPSBbLi4uY29tbWFuZCwgLi4udGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLCAuLi5hcmdzXTtcbiAgbG9nLmRlYnVnKGBDcmVhdGluZyAke0lEQl9FWEVDVVRBQkxFfSBzdWJwcm9jZXNzIHdpdGggYXJnczogJHt1dGlsLnF1b3RlKGFyZ3MpfWApO1xuICByZXR1cm4gbmV3IFN1YlByb2Nlc3ModGhpcy5leGVjdXRhYmxlLnBhdGgsIGlkYkFyZ3MsIG9wdHMpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc3lzdGVtQ2FsbE1ldGhvZHM7XG4iXSwiZmlsZSI6ImxpYi90b29scy9zeXN0ZW0tY29tbWFuZHMuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
