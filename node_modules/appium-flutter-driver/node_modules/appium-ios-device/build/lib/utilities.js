"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectPort = connectPort;
exports.connectPortSSL = connectPortSSL;
exports.getConnectedDevices = getConnectedDevices;
exports.getDeviceName = getDeviceName;
exports.getDeviceTime = getDeviceTime;
exports.getOSVersion = getOSVersion;
exports.startLockdownSession = startLockdownSession;

require("source-map-support/register");

var _usbmux = _interopRequireWildcard(require("./usbmux"));

var _sslHelper = require("./ssl-helper");

var _lodash = _interopRequireDefault(require("lodash"));

var _logger = _interopRequireDefault(require("./logger"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const LOCKDOWN_REQUEST = {
  DEVICE_TIME: {
    Key: 'TimeIntervalSince1970'
  },
  DEVICE_UTC_OFFSET: {
    Key: 'TimeZoneOffsetFromUTC'
  },
  DEVICE_TIME_ZONE: {
    Key: 'TimeZone'
  },
  DEVICE_VERSION: {
    Key: 'ProductVersion'
  },
  DEVICE_NAME: {
    Key: 'DeviceName'
  }
};

async function getConnectedDevices(socket = null) {
  let usbmux;

  try {
    usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));
  } catch (e) {
    _logger.default.debug(e);

    return [];
  }

  try {
    const devices = await usbmux.listDevices();
    const udids = devices.map(device => device.Properties.SerialNumber);
    return _lodash.default.uniq(udids);
  } finally {
    usbmux.close();
  }
}

async function getOSVersion(udid, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));

  try {
    const lockdown = await usbmux.connectLockdown(udid);
    return await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_VERSION);
  } finally {
    usbmux.close();
  }
}

async function getDeviceName(udid, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));

  try {
    const lockdown = await usbmux.connectLockdown(udid);
    return await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_NAME);
  } finally {
    usbmux.close();
  }
}

async function getDeviceTime(udid, socket = null) {
  const lockdown = await startLockdownSession(udid, socket);

  try {
    return {
      timestamp: await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_TIME),
      utcOffset: (await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_UTC_OFFSET)) / 60,
      timeZone: await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_TIME_ZONE)
    };
  } finally {
    lockdown.close();
  }
}

async function startLockdownSession(udid, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));

  try {
    const pairRecord = await usbmux.readPairRecord(udid);

    if (!pairRecord) {
      throw new Error(`Could not find a pair record for device '${udid}'. Please first pair with the device`);
    }

    const lockdown = await usbmux.connectLockdown(udid);
    await lockdown.startSession(pairRecord.HostID, pairRecord.SystemBUID);
    lockdown.enableSessionSSL(pairRecord.HostPrivateKey, pairRecord.HostCertificate);
    return lockdown;
  } catch (e) {
    usbmux.close();
    throw e;
  }
}

async function connectPortSSL(udid, port, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));

  try {
    const device = await usbmux.findDevice(udid);

    if (!device) {
      throw new Error(`Could not find the expected device '${udid}'`);
    }

    const pairRecord = await usbmux.readPairRecord(udid);

    if (!pairRecord) {
      throw new Error(`Could not find a pair record for device '${udid}'. Please first pair with the device`);
    }

    const socket = await usbmux.connect(device.Properties.DeviceID, port, undefined);
    return (0, _sslHelper.upgradeToSSL)(socket, pairRecord.HostPrivateKey, pairRecord.HostCertificate);
  } catch (e) {
    usbmux.close();
    throw e;
  }
}

async function connectPort(udid, port, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));

  try {
    const device = await usbmux.findDevice(udid);

    if (!device) {
      throw new Error(`Could not find the expected device ${udid}`);
    }

    return await usbmux.connect(device.Properties.DeviceID, port, undefined);
  } catch (e) {
    usbmux.close();
    throw e;
  }
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi91dGlsaXRpZXMuanMiXSwibmFtZXMiOlsiTE9DS0RPV05fUkVRVUVTVCIsIkRFVklDRV9USU1FIiwiS2V5IiwiREVWSUNFX1VUQ19PRkZTRVQiLCJERVZJQ0VfVElNRV9aT05FIiwiREVWSUNFX1ZFUlNJT04iLCJERVZJQ0VfTkFNRSIsImdldENvbm5lY3RlZERldmljZXMiLCJzb2NrZXQiLCJ1c2JtdXgiLCJVc2JtdXgiLCJlIiwibG9nIiwiZGVidWciLCJkZXZpY2VzIiwibGlzdERldmljZXMiLCJ1ZGlkcyIsIm1hcCIsImRldmljZSIsIlByb3BlcnRpZXMiLCJTZXJpYWxOdW1iZXIiLCJfIiwidW5pcSIsImNsb3NlIiwiZ2V0T1NWZXJzaW9uIiwidWRpZCIsImxvY2tkb3duIiwiY29ubmVjdExvY2tkb3duIiwiZ2V0VmFsdWUiLCJnZXREZXZpY2VOYW1lIiwiZ2V0RGV2aWNlVGltZSIsInN0YXJ0TG9ja2Rvd25TZXNzaW9uIiwidGltZXN0YW1wIiwidXRjT2Zmc2V0IiwidGltZVpvbmUiLCJwYWlyUmVjb3JkIiwicmVhZFBhaXJSZWNvcmQiLCJFcnJvciIsInN0YXJ0U2Vzc2lvbiIsIkhvc3RJRCIsIlN5c3RlbUJVSUQiLCJlbmFibGVTZXNzaW9uU1NMIiwiSG9zdFByaXZhdGVLZXkiLCJIb3N0Q2VydGlmaWNhdGUiLCJjb25uZWN0UG9ydFNTTCIsInBvcnQiLCJmaW5kRGV2aWNlIiwiY29ubmVjdCIsIkRldmljZUlEIiwidW5kZWZpbmVkIiwiY29ubmVjdFBvcnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUdBLE1BQU1BLGdCQUFnQixHQUFHO0FBQ3ZCQyxFQUFBQSxXQUFXLEVBQUU7QUFBRUMsSUFBQUEsR0FBRyxFQUFFO0FBQVAsR0FEVTtBQUV2QkMsRUFBQUEsaUJBQWlCLEVBQUU7QUFBRUQsSUFBQUEsR0FBRyxFQUFFO0FBQVAsR0FGSTtBQUd2QkUsRUFBQUEsZ0JBQWdC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IGdldERlZmF1bHRTb2NrZXQgfSBmcm9tICcuL3VzYm11eCc7XG5pbXBvcnQgeyB1cGdyYWRlVG9TU0wgfSBmcm9tICcuL3NzbC1oZWxwZXInO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2FtZG1hcnNoYWxsL2lPUy1JbnRlcm5hbHMvYmxvYi9tYXN0ZXIvbG9ja2JvdC9sb2NrYm90L2xvY2tkb3duX2tleXMuaFxuY29uc3QgTE9DS0RPV05fUkVRVUVTVCA9IHtcbiAgREVWSUNFX1RJTUU6IHsgS2V5OiAnVGltZUludGVydmFsU2luY2UxOTcwJyB9LFxuICBERVZJQ0VfVVRDX09GRlNFVDogeyBLZXk6ICdUaW1lWm9uZU9mZnNldEZyb21VVEMnIH0sXG4gIERFVklDRV9USU1FX1pPTkU6IHsgS2V5OiAnVGltZVpvbmUnIH0sXG4gIERFVklDRV9WRVJTSU9OOiB7IEtleTogJ1Byb2R1Y3RWZXJzaW9uJyB9LFxuICBERVZJQ0VfTkFNRTogeyBLZXk6ICdEZXZpY2VOYW1lJyB9XG59O1xuXG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB1ZGlkcyBvZiB0aGUgY29ubmVjdGVkIGRldmljZXNcbiAqXG4gKiBAcGFyYW0gez9uZXQuU29ja2V0fSBzb2NrZXQgdGhlIHNvY2tldCBvZiB1c2JtdXhkLiBJdCB3aWxsIGRlZmF1bHQgdG8gL3Zhci9ydW4vdXNibXV4ZCBpZiBpdCBpcyBub3QgcGFzc2VkXG4gKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IFRoZSBsaXN0IG9mIGRldmljZSBzZXJpYWwgbnVtYmVycyAodWRpZCkgb3JcbiAqIGFuIGVtcHR5IGxpc3QgaWYgbm8gZGV2aWNlcyBhcmUgY29ubmVjdGVkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldENvbm5lY3RlZERldmljZXMgKHNvY2tldCA9IG51bGwpIHtcbiAgbGV0IHVzYm11eDtcbiAgdHJ5IHtcbiAgICB1c2JtdXggPSBuZXcgVXNibXV4KHNvY2tldCB8fCBhd2FpdCBnZXREZWZhdWx0U29ja2V0KCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmRlYnVnKGUpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCB1c2JtdXgubGlzdERldmljZXMoKTtcbiAgICBjb25zdCB1ZGlkcyA9IGRldmljZXMubWFwKChkZXZpY2UpID0+IGRldmljZS5Qcm9wZXJ0aWVzLlNlcmlhbE51bWJlcik7XG4gICAgcmV0dXJuIF8udW5pcSh1ZGlkcyk7XG4gIH0gZmluYWxseSB7XG4gICAgdXNibXV4LmNsb3NlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIG9zIHZlcnNpb24gb2YgdGhlIGRldmljZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIERldmljZSBVRElEXG4gKiBAcGFyYW0gez9uZXQuU29ja2V0fSBzb2NrZXQgdGhlIHNvY2tldCBvZiB1c2JtdXhkLiBJdCB3aWxsIGRlZmF1bHQgdG8gL3Zhci9ydW4vdXNibXV4ZCBpZiBpdCBpcyBub3QgcGFzc2VkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRPU1ZlcnNpb24gKHVkaWQsIHNvY2tldCA9IG51bGwpIHtcbiAgY29uc3QgdXNibXV4ID0gbmV3IFVzYm11eChzb2NrZXQgfHwgYXdhaXQgZ2V0RGVmYXVsdFNvY2tldCgpKTtcbiAgdHJ5IHtcbiAgICAvLyBsb2NrZG93biBkb2Vzbid0IG5lZWQgdG8gYmUgY2xvc2VkIHNpbmNlIGl0IHVzZXMgdGhlIHNhbWUgc29ja2V0IHVzYm11eCB1c2VzXG4gICAgY29uc3QgbG9ja2Rvd24gPSBhd2FpdCB1c2JtdXguY29ubmVjdExvY2tkb3duKHVkaWQpO1xuICAgIHJldHVybiBhd2FpdCBsb2NrZG93bi5nZXRWYWx1ZShMT0NLRE9XTl9SRVFVRVNULkRFVklDRV9WRVJTSU9OKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1c2JtdXguY2xvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbmFtZSBvZiB0aGUgZGV2aWNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgRGV2aWNlIFVESURcbiAqIEBwYXJhbSB7P25ldC5Tb2NrZXR9IHNvY2tldCB0aGUgc29ja2V0IG9mIHVzYm11eGQuIEl0IHdpbGwgZGVmYXVsdCB0byAvdmFyL3J1bi91c2JtdXhkIGlmIGl0IGlzIG5vdCBwYXNzZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldERldmljZU5hbWUgKHVkaWQsIHNvY2tldCA9IG51bGwpIHtcbiAgY29uc3QgdXNibXV4ID0gbmV3IFVzYm11eChzb2NrZXQgfHwgYXdhaXQgZ2V0RGVmYXVsdFNvY2tldCgpKTtcbiAgdHJ5IHtcbiAgICAvLyBsb2NrZG93biBkb2Vzbid0IG5lZWQgdG8gYmUgY2xvc2VkIHNpbmNlIGl0IHVzZXMgdGhlIHNhbWUgc29ja2V0IHVzYm11eCB1c2VzXG4gICAgY29uc3QgbG9ja2Rvd24gPSBhd2FpdCB1c2JtdXguY29ubmVjdExvY2tkb3duKHVkaWQpO1xuICAgIHJldHVybiBhd2FpdCBsb2NrZG93bi5nZXRWYWx1ZShMT0NLRE9XTl9SRVFVRVNULkRFVklDRV9OQU1FKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1c2JtdXguY2xvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERldmljZVRpbWVcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZXN0YW1wIFVuaXggdGltZXN0YW1wIGluIHNlY29uZHMgc2luY2UgMTk3MC0wMS0wMVQwMDowMDowMFpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1dGNPZmZzZXQgVGhlIGRpZmZlcmVuY2UgaW4gbWludXRlcyBiZXR3ZWVuIHRoZSBVVEMgdGltZSBhbmQgdGhlIGxvY2FsIGRldmljZSB0aW1lLlxuICogQ2FuIGJlIG5lZ2F0aXZlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRpbWVab25lIFRpbWUgem9uZSBuYW1lIGNvbmZpZ3VyZWQgb24gdGhlIGRldmljZSwgZm9yIGV4YW1wbGUgYEV1cm9wZS9QYXJpc2BcbiAqL1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbG9jYWwgdGltZSBmcm9tIHRoZSBkZXZpY2UgdW5kZXIgdGVzdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIERldmljZSBVRElEXG4gKiBAcGFyYW0gez9uZXQuU29ja2V0fSBzb2NrZXQgdGhlIHNvY2tldCBvZiB1c2JtdXhkLiBJdCB3aWxsIGRlZmF1bHQgdG8gL3Zhci9ydW4vdXNibXV4ZCBpZiBpdCBpcyBub3QgcGFzc2VkXG4gKiBAcmV0dXJucyB7RGV2aWNlVGltZX1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGV2aWNlVGltZSAodWRpZCwgc29ja2V0ID0gbnVsbCkge1xuICBjb25zdCBsb2NrZG93biA9IGF3YWl0IHN0YXJ0TG9ja2Rvd25TZXNzaW9uKHVkaWQsIHNvY2tldCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpbWVzdGFtcDogYXdhaXQgbG9ja2Rvd24uZ2V0VmFsdWUoTE9DS0RPV05fUkVRVUVTVC5ERVZJQ0VfVElNRSksXG4gICAgICAvLyBBcHBsZSByZXR1cm5zIHV0Y09mZnNldCBpbiBzZWNvbmRzIHdoaWNoIGRvZXNudCBjb21wbHkgd2l0aCB0aGUgZ2VuZXJhbCBzdGFuZGFyZFxuICAgICAgdXRjT2Zmc2V0OiBhd2FpdCBsb2NrZG93bi5nZXRWYWx1ZShMT0NLRE9XTl9SRVFVRVNULkRFVklDRV9VVENfT0ZGU0VUKSAvIDYwLFxuICAgICAgdGltZVpvbmU6IGF3YWl0IGxvY2tkb3duLmdldFZhbHVlKExPQ0tET1dOX1JFUVVFU1QuREVWSUNFX1RJTUVfWk9ORSksXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBsb2NrZG93bi5jbG9zZSgpO1xuICB9XG59XG5cbi8qKlxuICogU3RhcnRzIGEgbG9ja2Rvd24gc2Vzc2lvbiBvbiB0aGUgZ2l2ZW4gZGV2aWNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgRGV2aWNlIFVESURcbiAqIEBwYXJhbSB7P25ldC5Tb2NrZXR9IHNvY2tldCB0aGUgc29ja2V0IG9mIHVzYm11eGQuIEl0IHdpbGwgZGVmYXVsdCB0byAvdmFyL3J1bi91c2JtdXhkIGlmIGl0IGlzIG5vdCBwYXNzZWRcbiAqIEByZXR1cm5zIHtMb2NrZG93bn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3RhcnRMb2NrZG93blNlc3Npb24gKHVkaWQsIHNvY2tldCA9IG51bGwpIHtcbiAgY29uc3QgdXNibXV4ID0gbmV3IFVzYm11eChzb2NrZXQgfHwgYXdhaXQgZ2V0RGVmYXVsdFNvY2tldCgpKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYWlyUmVjb3JkID0gYXdhaXQgdXNibXV4LnJlYWRQYWlyUmVjb3JkKHVkaWQpO1xuICAgIGlmICghcGFpclJlY29yZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhIHBhaXIgcmVjb3JkIGZvciBkZXZpY2UgJyR7dWRpZH0nLiBQbGVhc2UgZmlyc3QgcGFpciB3aXRoIHRoZSBkZXZpY2VgKTtcbiAgICB9XG4gICAgLy8gbG9ja2Rvd24gZG9lc24ndCBuZWVkIHRvIGJlIGNsb3NlZCBzaW5jZSBpdCB1c2VzIHRoZSBzYW1lIHNvY2tldCB1c2JtdXggdXNlc1xuICAgIGNvbnN0IGxvY2tkb3duID0gYXdhaXQgdXNibXV4LmNvbm5lY3RMb2NrZG93bih1ZGlkKTtcbiAgICBhd2FpdCBsb2NrZG93bi5zdGFydFNlc3Npb24ocGFpclJlY29yZC5Ib3N0SUQsIHBhaXJSZWNvcmQuU3lzdGVtQlVJRCk7XG4gICAgbG9ja2Rvd24uZW5hYmxlU2Vzc2lvblNTTChwYWlyUmVjb3JkLkhvc3RQcml2YXRlS2V5LCBwYWlyUmVjb3JkLkhvc3RDZXJ0aWZpY2F0ZSk7XG4gICAgcmV0dXJuIGxvY2tkb3duO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdXNibXV4LmNsb3NlKCk7XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG4vKipcbiAqIENvbm5lY3RzIHRvIGEgZ2l2ZW4gcG9ydCB3aXRoIHRoZSBjZXJ0cyBhbmQga2V5cyB1c2VkIGluIHRoZSBwYWlyaW5nIHByb2Nlc3NcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCBEZXZpY2UgVURJRFxuICogQHBhcmFtIHtudW1iZXJ9IHBvcnQgUG9ydCB0byBjb25uZWN0XG4gKiBAcGFyYW0gez9uZXQuU29ja2V0fSBzb2NrZXQgdGhlIHNvY2tldCBvZiB1c2JtdXhkLiBJdCB3aWxsIGRlZmF1bHQgdG8gL3Zhci9ydW4vdXNibXV4ZCBpZiBpdCBpcyBub3QgcGFzc2VkXG4gKiBAcmV0dXJucyB7dGxzLlRMU1NvY2tldHxPYmplY3R9IFRoZSBzb2NrZXQgb3IgdGhlIG9iamVjdCByZXR1cm5lZCBpbiB0aGUgY2FsbGJhY2sgaWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4aXN0c1xuICovXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0UG9ydFNTTCAodWRpZCwgcG9ydCwgc29ja2V0ID0gbnVsbCkge1xuICBjb25zdCB1c2JtdXggPSBuZXcgVXNibXV4KHNvY2tldCB8fCBhd2FpdCBnZXREZWZhdWx0U29ja2V0KCkpO1xuICB0cnkge1xuICAgIGNvbnN0IGRldmljZSA9IGF3YWl0IHVzYm11eC5maW5kRGV2aWNlKHVkaWQpO1xuICAgIGlmICghZGV2aWNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHRoZSBleHBlY3RlZCBkZXZpY2UgJyR7dWRpZH0nYCk7XG4gICAgfVxuICAgIGNvbnN0IHBhaXJSZWNvcmQgPSBhd2FpdCB1c2JtdXgucmVhZFBhaXJSZWNvcmQodWRpZCk7XG4gICAgaWYgKCFwYWlyUmVjb3JkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgcGFpciByZWNvcmQgZm9yIGRldmljZSAnJHt1ZGlkfScuIFBsZWFzZSBmaXJzdCBwYWlyIHdpdGggdGhlIGRldmljZWApO1xuICAgIH1cbiAgICBjb25zdCBzb2NrZXQgPSBhd2FpdCB1c2JtdXguY29ubmVjdChkZXZpY2UuUHJvcGVydGllcy5EZXZpY2VJRCwgcG9ydCwgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gdXBncmFkZVRvU1NMKHNvY2tldCwgcGFpclJlY29yZC5Ib3N0UHJpdmF0ZUtleSwgcGFpclJlY29yZC5Ib3N0Q2VydGlmaWNhdGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdXNibXV4LmNsb3NlKCk7XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG4vKipcbiAqIENvbm5lY3RzIHRvIGEgZ2l2ZW4gcG9ydFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIERldmljZSBVRElEXG4gKiBAcGFyYW0ge251bWJlcn0gcG9ydCBQb3J0IHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7P25ldC5Tb2NrZXR9IHNvY2tldCB0aGUgc29ja2V0IG9mIHVzYm11eGQuIEl0IHdpbGwgZGVmYXVsdCB0byAvdmFyL3J1bi91c2JtdXhkIGlmIGl0IGlzIG5vdCBwYXNzZWRcbiAqIEByZXR1cm5zIHtuZXQuU29ja2V0fE9iamVjdH0gVGhlIHNvY2tldCBvciB0aGUgb2JqZWN0IHJldHVybmVkIGluIHRoZSBjYWxsYmFjayBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhpc3RzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbm5lY3RQb3J0ICh1ZGlkLCBwb3J0LCBzb2NrZXQgPSBudWxsKSB7XG4gIGNvbnN0IHVzYm11eCA9IG5ldyBVc2JtdXgoc29ja2V0IHx8IGF3YWl0IGdldERlZmF1bHRTb2NrZXQoKSk7XG4gIHRyeSB7XG4gICAgY29uc3QgZGV2aWNlID0gYXdhaXQgdXNibXV4LmZpbmREZXZpY2UodWRpZCk7XG4gICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgdGhlIGV4cGVjdGVkIGRldmljZSAke3VkaWR9YCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB1c2JtdXguY29ubmVjdChkZXZpY2UuUHJvcGVydGllcy5EZXZpY2VJRCwgcG9ydCwgdW5kZWZpbmVkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHVzYm11eC5jbG9zZSgpO1xuICAgIHRocm93IGU7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgZ2V0Q29ubmVjdGVkRGV2aWNlcywgZ2V0T1NWZXJzaW9uLCBnZXREZXZpY2VOYW1lLCBnZXREZXZpY2VUaW1lLFxuICBzdGFydExvY2tkb3duU2Vzc2lvbiwgY29ubmVjdFBvcnQsIGNvbm5lY3RQb3J0U1NMLFxufTtcbiJdLCJmaWxlIjoibGliL3V0aWxpdGllcy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
