"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Usbmux = void 0;
exports.getDefaultSocket = getDefaultSocket;

require("source-map-support/register");

var _net = _interopRequireDefault(require("net"));

var _os = _interopRequireDefault(require("os"));

var _lodash = _interopRequireDefault(require("lodash"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _support = require("@appium/support");

var _lengthBasedSplitter = _interopRequireDefault(require("../util/transformer/length-based-splitter"));

var _usbmuxDecoder = _interopRequireDefault(require("./transformer/usbmux-decoder.js"));

var _usbmuxEncoder = _interopRequireDefault(require("./transformer/usbmux-encoder.js"));

var _path = _interopRequireDefault(require("path"));

var _plistService = _interopRequireDefault(require("../plist-service"));

var _lockdown = require("../lockdown");

var _baseService = require("../base-service");

var _constants = require("../constants");

const MAX_FRAME_SIZE = 1 * _constants.MB;
const USBMUX_RESULT = {
  OK: 0,
  BADCOMMAND: 1,
  BADDEV: 2,
  CONNREFUSED: 3
};
let name, version;

try {
  ({
    name,
    version
  } = require(_path.default.resolve(__dirname, '..', '..', '..', 'package.json')));
} catch (err) {
  ({
    name,
    version
  } = require(_path.default.resolve(__dirname, '..', '..', 'package.json')));
}

const DEFAULT_USBMUXD_SOCKET = '/var/run/usbmuxd';
const DEFAULT_USBMUXD_PORT = 27015;
const DEFAULT_USBMUXD_HOST = '127.0.0.1';
const PROG_NAME = name;
const CLIENT_VERSION_STRING = `${name}-${version}`;

function swap16(val) {
  return (val & 0xFF) << 8 | val >> 8 & 0xFF;
}

async function getDefaultSocket(opts = {}) {
  const {
    socketPath = DEFAULT_USBMUXD_SOCKET,
    socketPort = DEFAULT_USBMUXD_PORT,
    socketHost = DEFAULT_USBMUXD_HOST,
    timeout = 5000
  } = opts;
  let socket;

  if (await _support.fs.exists(socketPath)) {
    socket = _net.default.createConnection(socketPath);
  } else if (process.platform === 'win32' || process.platform === 'linux' && /microsoft/i.test(_os.default.release())) {
    socket = _net.default.createConnection(socketPort, socketHost);
  } else {
    throw new Error(`The usbmuxd socket at '${socketPath}' does not exist or is not accessible`);
  }

  return await new _bluebird.default((resolve, reject) => {
    socket.once('error', reject);
    socket.once('connect', () => resolve(socket));
  }).timeout(timeout);
}

class Usbmux extends _baseService.BaseServiceSocket {
  constructor(socketClient) {
    super(socketClient);
    this._decoder = new _usbmuxDecoder.default();
    this._splitter = new _lengthBasedSplitter.default({
      readableStream: socketClient,
      littleEndian: true,
      maxFrameLength: MAX_FRAME_SIZE,
      lengthFieldOffset: 0,
      lengthFieldLength: 4,
      lengthAdjustment: 0
    });

    this._socketClient.pipe(this._splitter).pipe(this._decoder);

    this._encoder = new _usbmuxEncoder.default();

    this._encoder.pipe(this._socketClient);

    this._assignClientFailureHandlers(this._encoder);

    this._tag = 0;
    this._responseCallbacks = {};

    this._decoder.on('data', this._handleData.bind(this));
  }

  _handleData(data) {
    const cb = this._responseCallbacks[data.header.tag] || _lodash.default.noop;
    cb(data);
  }

  async readBUID(timeout = 5000) {
    const {
      tag,
      receivePromise
    } = this._receivePlistPromise(timeout, data => {
      if (data.payload.BUID) {
        return data.payload.BUID;
      }

      throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
    });

    this._sendPlist({
      tag,
      payload: {
        MessageType: 'ReadBUID',
        ProgName: PROG_NAME,
        ClientVersionString: CLIENT_VERSION_STRING
      }
    });

    return await receivePromise;
  }

  async readPairRecord(udid, timeout = 5000) {
    const {
      tag,
      receivePromise
    } = this._receivePlistPromise(timeout, data => {
      if (!data.payload.PairRecordData) {
        return null;
      }

      try {
        return _support.plist.parsePlist(data.payload.PairRecordData);
      } catch (err) {
        throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
      }
    });

    this._sendPlist({
      tag,
      payload: {
        MessageType: 'ReadPairRecord',
        PairRecordID: udid,
        ProgName: PROG_NAME,
        ClientVersionString: CLIENT_VERSION_STRING
      }
    });

    return await receivePromise;
  }

  _sendPlist(json) {
    this._encoder.write(json);
  }

  _receivePlistPromise(timeout = 5000, responseCallback) {
    const tag = this._tag++;
    const receivePromise = new _bluebird.default((resolve, reject) => {
      this._responseCallbacks[tag] = data => {
        try {
          resolve(responseCallback(data));
        } catch (e) {
          reject(e);
        }
      };

      setTimeout(() => reject(new Error(`Failed to receive any data within the timeout: ${timeout}`)), timeout);
    });
    return {
      tag,
      receivePromise
    };
  }

  async listDevices(timeout = 5000) {
    const {
      tag,
      receivePromise
    } = this._receivePlistPromise(timeout, data => {
      if (data.payload.DeviceList) {
        return data.payload.DeviceList;
      }

      throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
    });

    this._sendPlist({
      tag,
      payload: {
        MessageType: 'ListDevices',
        ProgName: PROG_NAME,
        ClientVersionString: CLIENT_VERSION_STRING
      }
    });

    return await receivePromise;
  }

  async findDevice(udid, timeout = 5000) {
    const devices = await this.listDevices(timeout);
    return _lodash.default.find(devices, device => device.Properties.SerialNumber === udid);
  }

  async connectLockdown(udid, timeout = 5000) {
    const device = await this.findDevice(udid, timeout);

    if (!device) {
      throw new Error(`Could not find the expected device '${udid}'`);
    }

    const socket = await this.connect(device.Properties.DeviceID, _lockdown.LOCKDOWN_PORT, timeout);
    return new _lockdown.Lockdown(new _plistService.default(socket));
  }

  async connect(deviceID, port, timeout = 5000) {
    const {
      tag,
      receivePromise
    } = this._receivePlistPromise(timeout, data => {
      if (data.payload.MessageType !== 'Result') {
        throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
      }

      if (data.payload.Number === USBMUX_RESULT.OK) {
        this._splitter.shutdown();

        this._socketClient.unpipe(this._splitter);

        this._splitter.unpipe(this._decoder);

        return this._socketClient;
      } else if (data.payload.Number === USBMUX_RESULT.CONNREFUSED) {
        throw new Error(`Connection was refused to port ${port}`);
      } else {
        throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
      }
    });

    this._sendPlist({
      tag,
      payload: {
        MessageType: 'Connect',
        ProgName: PROG_NAME,
        ClientVersionString: CLIENT_VERSION_STRING,
        DeviceID: deviceID,
        PortNumber: swap16(port)
      }
    });

    return await receivePromise;
  }

}

exports.Usbmux = Usbmux;
var _default = Usbmux;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi91c2JtdXgvaW5kZXguanMiXSwibmFtZXMiOlsiTUFYX0ZSQU1FX1NJWkUiLCJNQiIsIlVTQk1VWF9SRVNVTFQiLCJPSyIsIkJBRENPTU1BTkQiLCJCQURERVYiLCJDT05OUkVGVVNFRCIsIm5hbWUiLCJ2ZXJzaW9uIiwicmVxdWlyZSIsInBhdGgiLCJyZXNvbHZlIiwiX19kaXJuYW1lIiwiZXJyIiwiREVGQVVMVF9VU0JNVVhEX1NPQ0tFVCIsIkRFRkFVTFRfVVNCTVVYRF9QT1JUIiwiREVGQVVMVF9VU0JNVVhEX0hPU1QiLCJQUk9HX05BTUUiLCJDTElFTlRfVkVSU0lPTl9TVFJJTkciLCJzd2FwMTYiLCJ2YWwiLCJnZXREZWZhdWx0U29ja2V0Iiwib3B0cyIsInNvY2tldFBhdGgiLCJzb2NrZXRQb3J0Iiwic29ja2V0SG9zdCIsInRpbWVvdXQiLCJzb2NrZXQiLCJmcyIsImV4aXN0cyIsIm5ldCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJwcm9jZXNzIiwicGxhdGZvcm0iLCJ0ZXN0Iiwib3MiLCJyZWxlYXNlIiwiRXJyb3IiLCJCIiwicmVqZWN0Iiwib25jZSIsIlVzYm11eCIsIkJhc2VTZXJ2aWNlU29ja2V0IiwiY29uc3RydWN0b3IiLCJzb2NrZXRDbGllbnQiLCJfZGVjb2RlciIsIlVzYm11eERlY29kZXIiLCJfc3BsaXR0ZXIiLCJMZW5ndGhCYXNlZFNwbGl0dGVyIiwicmVhZGFibGVTdHJlYW0iLCJsaXR0bGVFbmRpYW4iLCJtYXhGcmFtZUxlbmd0aCIsImxlbmd0aEZpZWxkT2Zmc2V0IiwibGVuZ3RoRmllbGRMZW5ndGgiLCJsZW5ndGhBZGp1c3RtZW50IiwiX3NvY2tldENsaWVudCIsInBpcGUiLCJfZW5jb2RlciIsIlVzYm11eEVuY29kZXIiLCJfYXNzaWduQ2xpZW50RmFpbHVyZUhhbmRsZXJzIiwiX3RhZyIsIl9yZXNwb25zZUNhbGxiYWNrcyIsIm9uIiwiX2hhbmRsZURhdGEiLCJiaW5kIiwiZGF0YSIsImNiIiwiaGVhZGVyIiwidGFnIiwiXyIsIm5vb3AiLCJyZWFkQlVJRCIsInJlY2VpdmVQcm9taXNlIiwiX3JlY2VpdmVQbGlzdFByb21pc2UiLCJwYXlsb2FkIiwiQlVJRCIsIkpTT04iLCJzdHJpbmdpZnkiLCJfc2VuZFBsaXN0IiwiTWVzc2FnZVR5cGUiLCJQcm9nTmFtZSIsIkNsaWVudFZlcnNpb25TdHJpbmciLCJyZWFkUGFpclJlY29yZCIsInVkaWQiLCJQYWlyUmVjb3JkRGF0YSIsInBsaXN0IiwicGFyc2VQbGlzdCIsIlBhaXJSZWNvcmRJRCIsImpzb24iLCJ3cml0ZSIsInJlc3BvbnNlQ2FsbGJhY2siLCJlIiwic2V0VGltZW91dCIsImxpc3REZXZpY2VzIiwiRGV2aWNlTGlzdCIsImZpbmREZXZpY2UiLCJkZXZpY2VzIiwiZmluZCIsImRldmljZSIsIlByb3BlcnRpZXMiLCJTZXJpYWxOdW1iZXIiLCJjb25uZWN0TG9ja2Rvd24iLCJjb25uZWN0IiwiRGV2aWNlSUQiLCJMT0NLRE9XTl9QT1JUIiwiTG9ja2Rvd24iLCJQbGlzdFNlcnZpY2UiLCJkZXZpY2VJRCIsInBvcnQiLCJOdW1iZXIiLCJzaHV0ZG93biIsInVucGlwZSIsIlBvcnROdW1iZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBLE1BQU1BLGNBQWMsR0FBRyxJQUFJQyxhQUEzQjtBQUVBLE1BQU1DLGFBQWEsR0FBRztBQUNwQkMsRUFBQUEsRUFBRSxFQUFFLENBRGdCO0FBRXBCQyxFQUFBQSxVQUFVLEVBQUUsQ0FGUTtBQUdwQkMsRUFBQUEsTUFBTSxFQUFFLENBSFk7QUFJcEJDLEVBQUFBLFdBQVcsRUFBRTtBQUpPLENBQXRCO0FBT0EsSUFBSUMsSUFBSixFQUFVQyxPQUFWOztBQUNBLElBQUk7QUFFRixHQUFDO0FBQUVELElBQUFBLElBQUY7QUFBUUMsSUFBQUE7QUFBUixNQUFvQkMsT0FBTyxDQUFDQyxj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IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IHBsaXN0LCBmcyB9IGZyb20gJ0BhcHBpdW0vc3VwcG9ydCc7XG5pbXBvcnQgTGVuZ3RoQmFzZWRTcGxpdHRlciBmcm9tICcuLi91dGlsL3RyYW5zZm9ybWVyL2xlbmd0aC1iYXNlZC1zcGxpdHRlcic7XG5pbXBvcnQgVXNibXV4RGVjb2RlciBmcm9tICcuL3RyYW5zZm9ybWVyL3VzYm11eC1kZWNvZGVyLmpzJztcbmltcG9ydCBVc2JtdXhFbmNvZGVyIGZyb20gJy4vdHJhbnNmb3JtZXIvdXNibXV4LWVuY29kZXIuanMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgUGxpc3RTZXJ2aWNlIGZyb20gJy4uL3BsaXN0LXNlcnZpY2UnO1xuaW1wb3J0IHsgTG9ja2Rvd24sIExPQ0tET1dOX1BPUlQgfSBmcm9tICcuLi9sb2NrZG93bic7XG5pbXBvcnQgeyBCYXNlU2VydmljZVNvY2tldCB9IGZyb20gJy4uL2Jhc2Utc2VydmljZSc7XG5pbXBvcnQgeyBNQiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cblxuY29uc3QgTUFYX0ZSQU1FX1NJWkUgPSAxICogTUI7XG5cbmNvbnN0IFVTQk1VWF9SRVNVTFQgPSB7XG4gIE9LOiAwLFxuICBCQURDT01NQU5EOiAxLFxuICBCQURERVY6IDIsXG4gIENPTk5SRUZVU0VEOiAzLFxufTtcblxubGV0IG5hbWUsIHZlcnNpb247XG50cnkge1xuICAvLyBmaXJzdCB0cnkgYXNzdW1pbmcgdGhpcyBpcyBpbiB0aGUgYGJ1aWxkYCBmb2xkZXJcbiAgKHsgbmFtZSwgdmVyc2lvbiB9ID0gcmVxdWlyZShwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nLCAncGFja2FnZS5qc29uJykpKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyB0aGVuIHRyeSBhc3N1bWluZyBpdCBpcyBub3RcbiAgKHsgbmFtZSwgdmVyc2lvbiB9ID0gcmVxdWlyZShwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAncGFja2FnZS5qc29uJykpKTtcbn1cblxuY29uc3QgREVGQVVMVF9VU0JNVVhEX1NPQ0tFVCA9ICcvdmFyL3J1bi91c2JtdXhkJztcbmNvbnN0IERFRkFVTFRfVVNCTVVYRF9QT1JUID0gMjcwMTU7XG5jb25zdCBERUZBVUxUX1VTQk1VWERfSE9TVCA9ICcxMjcuMC4wLjEnO1xuY29uc3QgUFJPR19OQU1FID0gbmFtZTtcbmNvbnN0IENMSUVOVF9WRVJTSU9OX1NUUklORyA9IGAke25hbWV9LSR7dmVyc2lvbn1gO1xuXG5mdW5jdGlvbiBzd2FwMTYgKHZhbCkge1xuICByZXR1cm4gKCh2YWwgJiAweEZGKSA8PCA4KSB8ICgodmFsID4+IDgpICYgMHhGRik7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU29ja2V0T3B0aW9uc1xuICogQHByb3BlcnR5IHs/c3RyaW5nfSBzb2NrZXRQYXRoIFsvdmFyL3J1bi91c2JtdXhkXSBUaGUgZnVsbCBwYXRoIHRvIHRoZSB1c2JtdXhkIFVuaXggc29ja2V0XG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IHNvY2tldFBvcnQgWzI3MDE1XSBUaGUgcG9ydCBudW1iZXIgdG8gY29ubmVjdCB0byBpZiBydW5uaW5nIG9uIFdpbmRvd3NcbiAqIG9yIGluIFdTTDEgbW9kZVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBzb2NrZXRIb3N0IFsxMjcuMC4wLjFdIFRoZSBob3N0IG5hbWUgdG8gY29ubmVjdCB0byBpZiBydW5uaW5nIG9uIFdpbmRvd3NcbiAqIG9yIGluIFdTTDEgbW9kZVxuICogQHByb3BlcnR5IHs/bnVtYmVyfSB0aW1lb3V0IFs1MDAwXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IHVudGlsXG4gKiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZFxuICovXG5cbi8qKlxuICogQ29ubmVjdHMgYSBzb2NrZXQgdG8gdXNibXV4ZCBzZXJ2aWNlXG4gKlxuICogQHBhcmFtIHs/U29ja2V0T3B0aW9uc30gb3B0c1xuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBhY2Nlc3NpbmcgdGhlIHNvY2tldCBvclxuICogYSBjb25uZWN0aW9uIGVycm9yIGhhcHBlbmVkXG4gKiBAdGhyb3dzIHtCLlRpbWVvdXRFcnJvcn0gaWYgY29ubmVjdGlvbiB0aW1lb3V0IGhhcHBlbmVkXG4gKiBAcmV0dXJucyB7bmV0LlNvY2tldH0gQ29ubmVjdGVkIHNvY2tldCBpbnN0YW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXREZWZhdWx0U29ja2V0IChvcHRzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHNvY2tldFBhdGggPSBERUZBVUxUX1VTQk1VWERfU09DS0VULFxuICAgIHNvY2tldFBvcnQgPSBERUZBVUxUX1VTQk1VWERfUE9SVCxcbiAgICBzb2NrZXRIb3N0ID0gREVGQVVMVF9VU0JNVVhEX0hPU1QsXG4gICAgdGltZW91dCA9IDUwMDAsXG4gIH0gPSBvcHRzO1xuXG4gIGxldCBzb2NrZXQ7XG4gIGlmIChhd2FpdCBmcy5leGlzdHMoc29ja2V0UGF0aCkpIHtcbiAgICBzb2NrZXQgPSBuZXQuY3JlYXRlQ29ubmVjdGlvbihzb2NrZXRQYXRoKTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gICAgICB8fCAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4JyAmJiAvbWljcm9zb2Z0L2kudGVzdChvcy5yZWxlYXNlKCkpKSkge1xuICAgIC8vIENvbm5lY3QgdG8gdXNibXV4ZCB3aGVuIHJ1bm5pbmcgb24gV1NMMVxuICAgIHNvY2tldCA9IG5ldC5jcmVhdGVDb25uZWN0aW9uKHNvY2tldFBvcnQsIHNvY2tldEhvc3QpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHVzYm11eGQgc29ja2V0IGF0ICcke3NvY2tldFBhdGh9JyBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYWNjZXNzaWJsZWApO1xuICB9XG5cbiAgcmV0dXJuIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzb2NrZXQub25jZSgnZXJyb3InLCByZWplY3QpO1xuICAgIHNvY2tldC5vbmNlKCdjb25uZWN0JywgKCkgPT4gcmVzb2x2ZShzb2NrZXQpKTtcbiAgfSkudGltZW91dCh0aW1lb3V0KTtcbn1cblxuXG5jbGFzcyBVc2JtdXggZXh0ZW5kcyBCYXNlU2VydmljZVNvY2tldCB7XG4gIGNvbnN0cnVjdG9yIChzb2NrZXRDbGllbnQpIHtcbiAgICBzdXBlcihzb2NrZXRDbGllbnQpO1xuXG4gICAgdGhpcy5fZGVjb2RlciA9IG5ldyBVc2JtdXhEZWNvZGVyKCk7XG4gICAgdGhpcy5fc3BsaXR0ZXIgPSBuZXcgTGVuZ3RoQmFzZWRTcGxpdHRlcih7XG4gICAgICByZWFkYWJsZVN0cmVhbTogc29ja2V0Q2xpZW50LFxuICAgICAgbGl0dGxlRW5kaWFuOiB0cnVlLFxuICAgICAgbWF4RnJhbWVMZW5ndGg6IE1BWF9GUkFNRV9TSVpFLFxuICAgICAgbGVuZ3RoRmllbGRPZmZzZXQ6IDAsXG4gICAgICBsZW5ndGhGaWVsZExlbmd0aDogNCxcbiAgICAgIGxlbmd0aEFkanVzdG1lbnQ6IDAsXG4gICAgfSk7XG4gICAgdGhpcy5fc29ja2V0Q2xpZW50LnBpcGUodGhpcy5fc3BsaXR0ZXIpLnBpcGUodGhpcy5fZGVjb2Rlcik7XG5cbiAgICB0aGlzLl9lbmNvZGVyID0gbmV3IFVzYm11eEVuY29kZXIoKTtcbiAgICB0aGlzLl9lbmNvZGVyLnBpcGUodGhpcy5fc29ja2V0Q2xpZW50KTtcbiAgICB0aGlzLl9hc3NpZ25DbGllbnRGYWlsdXJlSGFuZGxlcnModGhpcy5fZW5jb2Rlcik7XG5cbiAgICB0aGlzLl90YWcgPSAwO1xuICAgIHRoaXMuX3Jlc3BvbnNlQ2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5fZGVjb2Rlci5vbignZGF0YScsIHRoaXMuX2hhbmRsZURhdGEuYmluZCh0aGlzKSk7XG4gIH1cblxuICBfaGFuZGxlRGF0YSAoZGF0YSkge1xuICAgIGNvbnN0IGNiID0gdGhpcy5fcmVzcG9uc2VDYWxsYmFja3NbZGF0YS5oZWFkZXIudGFnXSB8fCBfLm5vb3A7XG4gICAgY2IoZGF0YSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tY2FsbGJhY2tzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgQlVJRCBvZiB0aGUgaG9zdCBjb21wdXRlciBmcm9tIHVzYm11eGRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0PTUwMDBdIHRoZSB0aW1lb3V0IG9mIHJlY2VpdmluZyBhIHJlc3BvbnNlIGZyb20gdXNibXV4ZFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgYXN5bmMgcmVhZEJVSUQgKHRpbWVvdXQgPSA1MDAwKSB7XG4gICAgY29uc3Qge3RhZywgcmVjZWl2ZVByb21pc2V9ID0gdGhpcy5fcmVjZWl2ZVBsaXN0UHJvbWlzZSh0aW1lb3V0LCAoZGF0YSkgPT4ge1xuICAgICAgaWYgKGRhdGEucGF5bG9hZC5CVUlEKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnBheWxvYWQuQlVJRDtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc2VuZFBsaXN0KHtcbiAgICAgIHRhZyxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgTWVzc2FnZVR5cGU6ICdSZWFkQlVJRCcsXG4gICAgICAgIFByb2dOYW1lOiBQUk9HX05BTUUsXG4gICAgICAgIENsaWVudFZlcnNpb25TdHJpbmc6IENMSUVOVF9WRVJTSU9OX1NUUklOR1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF3YWl0IHJlY2VpdmVQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBwYWlyIHJlY29yZCBvZiBhIGRldmljZS4gSXQgd2lsbCByZXR1cm4gbnVsbCBpZiBpdCBkb2Vzbid0IGV4aXN0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdWRpZCB0aGUgdWRpZCBvZiB0aGUgZGV2aWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dD01MDAwXSB0aGUgdGltZW91dCBvZiByZWNlaXZpbmcgYSByZXNwb25zZSBmcm9tIHVzYm11eGRcbiAgICogQHJldHVybnMgez9PYmplY3R9XG4gICAqL1xuICBhc3luYyByZWFkUGFpclJlY29yZCAodWRpZCwgdGltZW91dCA9IDUwMDApIHtcbiAgICBjb25zdCB7dGFnLCByZWNlaXZlUHJvbWlzZX0gPSB0aGlzLl9yZWNlaXZlUGxpc3RQcm9taXNlKHRpbWVvdXQsIChkYXRhKSA9PiB7XG4gICAgICBpZiAoIWRhdGEucGF5bG9hZC5QYWlyUmVjb3JkRGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBwbGlzdC5wYXJzZVBsaXN0KGRhdGEucGF5bG9hZC5QYWlyUmVjb3JkRGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZW5kUGxpc3Qoe1xuICAgICAgdGFnLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBNZXNzYWdlVHlwZTogJ1JlYWRQYWlyUmVjb3JkJyxcbiAgICAgICAgUGFpclJlY29yZElEOiB1ZGlkLFxuICAgICAgICBQcm9nTmFtZTogUFJPR19OQU1FLFxuICAgICAgICBDbGllbnRWZXJzaW9uU3RyaW5nOiBDTElFTlRfVkVSU0lPTl9TVFJJTkdcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVjZWl2ZVByb21pc2U7XG4gIH1cblxuICBfc2VuZFBsaXN0IChqc29uKSB7XG4gICAgdGhpcy5fZW5jb2Rlci53cml0ZShqc29uKTtcbiAgfVxuXG4gIF9yZWNlaXZlUGxpc3RQcm9taXNlICh0aW1lb3V0ID0gNTAwMCwgcmVzcG9uc2VDYWxsYmFjaykge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuX3RhZysrO1xuICAgIGNvbnN0IHJlY2VpdmVQcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fcmVzcG9uc2VDYWxsYmFja3NbdGFnXSA9IChkYXRhKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXNwb25zZUNhbGxiYWNrKGRhdGEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlY2VpdmUgYW55IGRhdGEgd2l0aGluIHRoZSB0aW1lb3V0OiAke3RpbWVvdXR9YCkpLCB0aW1lb3V0KTtcbiAgICB9KTtcbiAgICByZXR1cm4ge3RhZywgcmVjZWl2ZVByb21pc2V9O1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBkZXZpY2VzIGNvbm5lY3RlZCB0byB0aGUgaG9zdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXQ9NTAwMF0gdGhlIHRpbWVvdXQgb2YgcmVjZWl2aW5nIGEgcmVzcG9uc2UgZnJvbSB1c2JtdXhkXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIGFzeW5jIGxpc3REZXZpY2VzICh0aW1lb3V0ID0gNTAwMCkge1xuICAgIGNvbnN0IHt0YWcsIHJlY2VpdmVQcm9taXNlfSA9IHRoaXMuX3JlY2VpdmVQbGlzdFByb21pc2UodGltZW91dCwgKGRhdGEpID0+IHtcbiAgICAgIGlmIChkYXRhLnBheWxvYWQuRGV2aWNlTGlzdCkge1xuICAgICAgICByZXR1cm4gZGF0YS5wYXlsb2FkLkRldmljZUxpc3Q7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3NlbmRQbGlzdCh7XG4gICAgICB0YWcsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIE1lc3NhZ2VUeXBlOiAnTGlzdERldmljZXMnLFxuICAgICAgICBQcm9nTmFtZTogUFJPR19OQU1FLFxuICAgICAgICBDbGllbnRWZXJzaW9uU3RyaW5nOiBDTElFTlRfVkVSU0lPTl9TVFJJTkdcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhd2FpdCByZWNlaXZlUHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rcyBmb3IgYSBkZXZpY2Ugd2l0aCB0aGUgcGFzc2VkIHVkaWQuIEl0IHdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgZGV2aWNlIGlzIG5vdCBmb3VuZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdWRpZCB0aGUgdWRpZCBvZiB0aGUgZGV2aWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dD01MDAwXSB0aGUgdGltZW91dCBvZiByZWNlaXZpbmcgYSByZXNwb25zZSBmcm9tIHVzYm11eGRcbiAgICogQHJldHVybnMgez9PYmplY3R9XG4gICAqL1xuICBhc3luYyBmaW5kRGV2aWNlICh1ZGlkLCB0aW1lb3V0ID0gNTAwMCkge1xuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCB0aGlzLmxpc3REZXZpY2VzKHRpbWVvdXQpO1xuICAgIHJldHVybiBfLmZpbmQoZGV2aWNlcywgKGRldmljZSkgPT4gZGV2aWNlLlByb3BlcnRpZXMuU2VyaWFsTnVtYmVyID09PSB1ZGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgbG9ja2Rvd25kIG9uIHRoZSBkZXZpY2UgYW5kIHJldHVybnMgYSBMb2NrZG93biBjbGllbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgdGhlIHVkaWQgb2YgdGhlIGRldmljZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXQ9NTAwMF0gdGhlIHRpbWVvdXQgb2YgcmVjZWl2aW5nIGEgcmVzcG9uc2UgZnJvbSB1c2JtdXhkXG4gICAqIEByZXR1cm5zIHtMb2NrZG93bn1cbiAgICovXG4gIGFzeW5jIGNvbm5lY3RMb2NrZG93biAodWRpZCwgdGltZW91dCA9IDUwMDApIHtcbiAgICBjb25zdCBkZXZpY2UgPSBhd2FpdCB0aGlzLmZpbmREZXZpY2UodWRpZCwgdGltZW91dCk7XG4gICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgdGhlIGV4cGVjdGVkIGRldmljZSAnJHt1ZGlkfSdgKTtcbiAgICB9XG4gICAgY29uc3Qgc29ja2V0ID0gYXdhaXQgdGhpcy5jb25uZWN0KGRldmljZS5Qcm9wZXJ0aWVzLkRldmljZUlELCBMT0NLRE9XTl9QT1JULCB0aW1lb3V0KTtcbiAgICByZXR1cm4gbmV3IExvY2tkb3duKG5ldyBQbGlzdFNlcnZpY2Uoc29ja2V0KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gYSBjZXJ0YWluIHBvcnQgb24gdGhlIGRldmljZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGV2aWNlSUQgdGhlIGRldmljZSBpZCB3aGljaCBjYW4gYmUgcmV0cmlldmVkIGZyb20gdGhlIHByb3BlcnRpZXMgb2YgYSBkZXZpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnQgdGhlIHBvcnQgbnVtYmVyIHRoYXQgd2FudHMgdG8gYmUgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dD01MDAwXSB0aGUgdGltZW91dCBvZiByZWNlaXZpbmcgYSByZXNwb25zZSBmcm9tIHVzYm11eGRcbiAgICogQHJldHVybnMge25ldC5Tb2NrZXR8T2JqZWN0fSBUaGUgc29ja2V0IG9yIHRoZSBvYmplY3QgcmV0dXJuZWQgaW4gdGhlIGNhbGxiYWNrIGlmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBleGlzdHNcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QgKGRldmljZUlELCBwb3J0LCB0aW1lb3V0ID0gNTAwMCkge1xuICAgIGNvbnN0IHt0YWcsIHJlY2VpdmVQcm9taXNlfSA9IHRoaXMuX3JlY2VpdmVQbGlzdFByb21pc2UodGltZW91dCwgKGRhdGEpID0+IHtcbiAgICAgIGlmIChkYXRhLnBheWxvYWQuTWVzc2FnZVR5cGUgIT09ICdSZXN1bHQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWApO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEucGF5bG9hZC5OdW1iZXIgPT09IFVTQk1VWF9SRVNVTFQuT0spIHtcbiAgICAgICAgdGhpcy5fc3BsaXR0ZXIuc2h1dGRvd24oKTtcbiAgICAgICAgdGhpcy5fc29ja2V0Q2xpZW50LnVucGlwZSh0aGlzLl9zcGxpdHRlcik7XG4gICAgICAgIHRoaXMuX3NwbGl0dGVyLnVucGlwZSh0aGlzLl9kZWNvZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvY2tldENsaWVudDtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5wYXlsb2FkLk51bWJlciA9PT0gVVNCTVVYX1JFU1VMVC5DT05OUkVGVVNFRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gd2FzIHJlZnVzZWQgdG8gcG9ydCAke3BvcnR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX3NlbmRQbGlzdCh7XG4gICAgICB0YWcsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIE1lc3NhZ2VUeXBlOiAnQ29ubmVjdCcsXG4gICAgICAgIFByb2dOYW1lOiBQUk9HX05BTUUsXG4gICAgICAgIENsaWVudFZlcnNpb25TdHJpbmc6IENMSUVOVF9WRVJTSU9OX1NUUklORyxcbiAgICAgICAgRGV2aWNlSUQ6IGRldmljZUlELFxuICAgICAgICBQb3J0TnVtYmVyOiBzd2FwMTYocG9ydClcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhd2FpdCByZWNlaXZlUHJvbWlzZTtcbiAgfVxufVxuXG5leHBvcnQgeyBVc2JtdXgsIGdldERlZmF1bHRTb2NrZXQgfTtcbmV4cG9ydCBkZWZhdWx0IFVzYm11eDtcbiJdLCJmaWxlIjoibGliL3VzYm11eC9pbmRleC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
